{"pages":[],"posts":[{"title":"面试中的dp常见问题","text":"常见问题：有限集的最优 动态规划阶段： 状态表示，化零为整 状态计算，化整为零 划分依据：寻找最后一个不同点 【题目】01背包有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。 第 i件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式输出一个整数，表示最大价值。 数据范围0&lt;N,V≤10000&lt;N,V≤10000&lt;vi,wi≤10000&lt;vi,wi≤1000 输入样例123454 51 22 43 44 5 输出样例：18 代码朴素写法 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N][N];int main() { cin &gt;&gt; n &gt;&gt; m ; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; v[i] &gt;&gt; w[i]; } for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; // 不加上v[i]的价值w[i]； if (j &gt;= v[i]) // 如果当前v[i]的体积小于等于最大的体积，则考虑将v[i]放进去的价值 f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]); } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 简单优化 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N];int main() { cin &gt;&gt; n &gt;&gt; m ; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; v[i] &gt;&gt; w[i]; } for (int i = 1; i &lt;= n; i++) for (int j = m; j &gt;= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;}","link":"/2021/06/28/about-dp/"},{"title":"面试中的linux常见问题","text":"linux是后端程序员面试必不可少的一个技能，整理一些面试会经常被问到的问题，便于复习查阅。 1. 绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？ 绝对路径： 如/etc/init.d 当前目录和上层目录： ./ ../ 主目录： ~/ 切换目录： cd 2. 怎么查看当前进程？怎么执行退出？怎么查看当前路径？ 查看当前进程： ps 执行退出： exit 查看当前路径： pwd 3.怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？ 清屏： clear 退出当前命令： ctrl+c 彻底退出 执行睡眠 ： ctrl+z 挂起当前进程fg 恢复后台 查看当前用户 id： “id”：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名 查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser –help 这个告诉你一些常用参数； info adduesr； 4. Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？ ls 执行的功能： 列出指定目录中的目录，以及文件 哪些参数以及区别： a 所有文件l 详细信息，包括大小字节数，可读可写可执行的权限等 5. 建立软链接(快捷方式)，以及硬链接的命令。 软链接： ln -s slink source 硬链接： ln link source 6. 目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？ 创建目录： mkdir 创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件 复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？ 文件权限修改： chmod 格式如下： chmodu+xfile给file的属主增加执行权限chmodu+xfile给file的属主增加执行权限 chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限 chmodu=rwx,g=rx,o=xfile上例的另一种形式chmodu=rwx,g=rx,o=xfile上例的另一种形式 chmod =r file 为所有用户分配读权限 chmod444file同上例chmod444file同上例 chmod a-wx,a+r file同上例 $ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限 7. 查看文件内容有哪些命令可以使用？ vi 文件名 #编辑方式查看，可修改 cat 文件名 #显示全部文件内容 more 文件名 #分页显示文件内容 less 文件名 #与 more 相似，更好的是可以往前翻页 tail 文件名 #仅查看尾部，还可以指定行数 head 文件名 #仅查看头部,还可以指定行数 8. 随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”? 写文件命令：vi 向屏幕输出带空格的字符串: echo &quot;hello world&quot; 9. 终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？ 终端 /dev/tty 黑洞文件 /dev/null 10. 移动文件用哪个命令？改名用哪个命令？ 移动文件：mv 改名：mv 11. 复制文件用哪个命令？如果需要连同文件夹一块复制呢？ cp cp -r 12. 删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？ rm rm -r rmdir 13. Linux 下命令有哪几种可使用的通配符？分别代表什么含义? ？可替代单个字符。 *可替代任意多个字符。 方括号[charset]可替代 charset 集中的任何单个字符，如[a-z]，[abABC] 14. 用什么命令对一个文件的内容进行统计？(行号、单词数、字节数) wc 命令 -c 统计字节数 -l 统计行数 -w 统计字数。 15. Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。grep [stringSTRING] filename grep [^string] filename 16. Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？ 不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。 暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。 就绪状态：在 run_queue 队列里的状态 运行状态：在 run_queue 队列里的状态 可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起 zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉 退出状态 D 不可中断 Uninterruptible（usually IO） R 正在运行，或在队列中的进程 S 处于休眠状态 T 停止或被追踪 Z 僵尸进程 W 进入内存交换（从内核 2.6 开始无效） X 死掉的进程 17. 怎么使一个命令在后台运行?一般都是使用 &amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格) 18. 利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进程的信息？ ps -ef (system v 输出) ps -aux bsd 格式输出 ps -ef | grep pid 19. 哪个命令专门用来查看后台任务? job -l 20. 把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令? 把后台任务调到前台执行 fg 把停下的后台任务在后台执行起来 bg 21. 终止进程用什么命令? 带什么参数? kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;] kill-9 pid 22. 怎么查看系统支持的所有信号？kill -l 23. 搜索文件用什么命令? 格式是怎么样的?命令： find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt; whereis 加参数与文件名 locate 只加文件名 find 直接搜索磁盘，较慢。 格式： find / -name “string*” 24. 查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令? 查找自己所在的终端信息：who am i 查看当前谁在使用该主机：who 25. 使用什么命令查看用过的命令列表? history history 26. 使用什么命令查看磁盘使用空间？ 空闲空间呢?使用什么命令查看磁盘使用空间？ 空闲空间呢? df -hl 文件系统 容量 已用 可用 已用% 挂载点 12Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% //dev/hda1 494M 19M 450M 4% /boot 27. 使用什么命令查看网络是否连通? netstat 28. 使用什么命令查看 ip 地址及接口信息？使用什么命令查看 ip 地址及接口信息？ ifconfig 29. 查看各类环境变量用什么命令? 查看所有 env 查看某个，如 home： env $HOME 30. 通过什么命令指定命令提示符?通过什么命令指定命令提示符? \\u：显示当前用户账号 \\h：显示当前主机名 \\W：只显示当前路径最后一个目录 \\w：显示当前绝对路径（当前用户目录会以~代替） $PWD：显示当前全路径 $：显示命令行’$’或者’#’符号 #：下达的第几个命令 \\d：代表日期，格式为week day month date，例如：”MonAug1” \\t：显示时间为24小时格式，如：HH：MM：SS \\T：显示时间为12小时格式 \\A：显示时间为24小时格式：HH：MM \\v：BASH的版本信息 如export PS1=’[\\u@\\h\\w#]$’ 31. 查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加?查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加? whereis -bfmsu-M &lt;目录&gt;…[文件…] whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…] 补充说明：whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。 -b 只查找二进制文件。 -B&lt;目录&gt; 只在设置的目录下查找二进制文件。 -f 不显示文件名前的路径名称。 -m 只查找说明文件。 -M&lt;目录&gt; 只在设置的目录下查找说明文件。 -s 只查找原始代码文件。 -S&lt;目录&gt; 只在设置的目录下查找原始代码文件。 -u 查找不包含指定类型的文件。which 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 -p 与-n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位的宽度。 -V 显示版本信息 32. 通过什么命令查找执行命令? which 只能查可执行文件 whereis 只能查二进制文件、说明文档，源文件等 33. 怎么对命令进行取别名？ alias la=’ls -a’ 34. du 和 df 的定义，以及区别？ du 显示目录或文件的大小 df 显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配图并考虑 Meta Data。 df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。 35. awk 详解。 awk '{pattern + action}' {filenames}#cat /etc/passwd |awk -F ‘:’ ‘{print 1”\\t”1”\\t”7}’ //-F 的意思是以’:’分隔 root /bin/bashdaemon /bin/sh 搜索/etc/passwd 有 root 关键字的所有行 36. 当你需要给命令绑定一个宏或者按键的时候，应该怎么做呢？ 可以使用bind命令，bind可以很方便地在shell中实现宏或按键的绑定。 在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。 比如获取F12的字符序列获取方法如下：先按下Ctrl+V,然后按下F12 .我们就可以得到F12的字符序列 ^[[24~。 接着使用bind进行绑定。 [root@localhost ~]# bind '&quot;\\e[24~&quot;:&quot;date&quot;' 注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。 【附】也可以使用showkey -a命令查看按键对应的字符序列。 37. 如果一个linux新手想要知道当前系统支持的所有命令的列表，他需要怎么做？ 使用命令compgen ­-c，可以打印出所有支持的命令列表。 38. 如果你的助手想要打印出当前的目录栈，你会建议他怎么做？ 使用Linux 命令dirs可以将当前的目录栈打印出来。 12[root@localhost ~]# dirs/usr/share/X11 【附】：目录栈通过pushd popd来操作。 39. 你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？ 使用linux命令 disown -r 可以将所有正在运行的进程移除。 40. bash shell 中的hash 命令有什么作用？ linux命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径, 用该命令可以打印出你所使用过的命令以及执行的次数。 41. 哪一个bash内置命令能够进行数学运算。bash shell 的内置命令let 可以进行整型数的数学运算。 123456\\#! /bin/bash……let c=a+b…… 42. 怎样一页一页地查看一个大文件的内容呢？ 通过管道将命令”cat file_name.txt” 和 ‘more’ 连接在一起可以实现这个需要. 1[root@localhost ~]# cat file_name.txt | more 43. 数据字典属于哪一个用户的？数据字典是属于’SYS’用户的，用户’SYS’ 和 ‘SYSEM’是由系统默认自动创建的 44. 怎样查看一个linux命令的概要与用法？假设你在/bin目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？使用命令whatis 可以先出显示出这个命令的用法简要，比如，你可以使用whatis zcat 去查看’zcat’的介绍以及使用简要。 12[root@localhost ~]# whatis zcatzcat [gzip] (1) - compress or expand files 45. 使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？使用命令repquota 能够显示出一个文件系统的配额信息 【附】只有root用户才能够查看其它用户的配额。","link":"/2021/06/28/about-linux/"},{"title":"面试中的指针常见问题","text":"指针常量与常量指针 数组指针与指针数组 指针的指针 指针常量与常量指针大家看看如下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;void fun_p1(){ // 指向一个常量字符串的指针 const char *p1 = &quot;p1 string&quot;; printf(&quot;p1: %s\\n&quot;, p1); //尝试修改p1指向地址的值，发现可以修改 p1 = &quot;p1 string change&quot;; printf(&quot;p1: %s\\n&quot;, p1); //尝试修改p1的指向地址; const char *p_tmp = &quot;i am p_tmp string&quot;; p1 = p_tmp; printf(&quot;p1: %s\\n&quot;, p1);}void fun_p2(){ // 字符常量指针 char const *p2 = &quot;p2 string&quot;; printf(&quot;p2: %s\\n&quot;, p2); // 尝试修改p2指向地址的值,发现可以修改 p2 = &quot;p2 string change&quot;; printf(&quot;p2: %s\\n&quot;, p2); // 尝试修改p2指向的地址 const char *p_tmp = &quot;i am p_tmp string&quot;; p2 = p_tmp; printf(&quot;p2: %s\\n&quot;, p2);}void fun_p3(){ // 字符常量指针 //char * const p3 = &quot;p3 string&quot;; // 编译器警告: SO C++11 does not allow conversion from string literal to 'char *const' //printf(&quot;p3: %s\\n&quot;, p3); // 尝试修改p3指向地址的值,发现可以修改 //p3 = &quot;p3 string change&quot;; // 编译器提示：Cannot assign to variable 'p3' with const-qualified type 'char *const' //printf(&quot;p3: %s\\n&quot;, p3); // 尝试修改p3指向的地址 //const char *p_tmp = &quot;i am p_tmp string&quot;; //p3 = p_tmp; // 编译器提示：Cannot assign to variable 'p3' with const-qualified type 'char *const' //printf(&quot;p3: %s\\n&quot;, p3);}void fun_p4(){ // 字符常量指针 char const * const p4 = &quot;p4 string&quot;; printf(&quot;p4: %s\\n&quot;, p4); // 尝试修改p4指向地址的值,发现可以修改 //p4 = &quot;p4 string change&quot;; // 编译器提示： Cannot assign to variable 'p4' with const-qualified type 'const char *const' //printf(&quot;p4: %s\\n&quot;, p4); // 尝试修改p4指向的地址 //const char *p_tmp = &quot;i am p_tmp string&quot;; //p4 = p_tmp; // 编译器提示：Cannot assign to variable 'p4' with const-qualified type 'const char *const' //printf(&quot;p4: %s\\n&quot;, p4);}int main(int argc, const char * argv[]) { fun_p1(); // const T *p = &amp;; 可以修改地址，可以修改地址上的值 fun_p2(); // T const *p = &amp;; 可以修改地址，可以修改地址上的值 fun_p3(); // T * const p = &amp;; 不可以修改地址，不可以修改地址上的值, c11不推荐使用这种方式定义变量 fun_p4(); // T const * const p = &amp;; 不可以修改地址，不可以修改地址上的值 return 0;} 通过代码可以发现，我们最常使用的const char *str = &quot;hello world&quot;的使用方法，可以直接修改指针指向的地址，也可以修改指向地址中的内容。","link":"/2021/06/28/about-pointer/"},{"title":"左值、右值引用、move语义和完美转发","text":"左值、右值引用、move语义和完美转发 相关概念 左值、右值、纯右值、将亡值、左值引用、右值引用、移动语义、完美转发、返回值优化。 1. 左值、右值概念1： 左值：可以放到等号左边的东西叫左值。 右值：不可以放到等号左边的东西就叫右值。 概念2： 左值：可以取地址并且有名字的东西就是左值。 右值：不能取地址的没有名字的东西就是右值。 举例： 1int a = b + c; a是左值，有变量名，可以取地址，也可以放到等号左边, 表达式b+c的返回值是右值，没有名字且不能取地址，&amp;(b+c)不能通过编译，而且也不能放到等号左边。 1int a = 4; // a是左值，4作为普通字面量是右值 左值一般有： 函数名和变量名 返回左值引用的函数调用 前置自增自减表达式++i、–i 由赋值表达式或赋值运算符连接的表达式(a=b, a += b等) 解引用表达式*p 字符串字面值”abcd” 2. 纯右值、将亡值纯右值和将亡值都属于右值。 纯右值运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。 除字符串字面值外的字面值 返回非引用类型的函数调用 后置自增自减表达式i++、i– 算术表达式(a+b, a*b, a&amp;&amp;b, a==b等) 取地址表达式等(&amp;a) 将亡值将亡值是指C++11新增的和右值引用相关的表达式，通常指将要被移动的对象、T&amp;&amp;函数的返回值、std::move函数的返回值、转换为T&amp;&amp;类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。 123456class A { xxx;};A a;auto c = std::move(a); // c是将亡值auto d = static_cast&lt;A&amp;&amp;&gt;(a); // d是将亡值 3. 左值引用、右值引用根据名字大概就可以猜到意思，左值引用就是对左值进行引用的类型，右值引用就是对右值进行引用的类型，他们都是引用，都是对象的一个别名，并不拥有所绑定对象的堆存，所以都必须立即初始化。 12type &amp;name = exp; // 左值引用type &amp;&amp;name = exp; // 右值引用 左值引用 12345int a = 5;int &amp;b = a; // b是左值引用b = 4;int &amp;c = 10; // error，10无法取地址，无法进行引用const int &amp;d = 10; // ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址 可以得出结论：对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用const引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用。 右值引用 如果使用右值引用，那表达式等号右边的值需要时右值，可以使用std::move函数强制把左值转换为右值。 123int a = 4;int &amp;&amp;b = a; // error, a是左值int &amp;&amp;c = std::move(a); // ok 4. 移动语义谈移动语义前，我们首先需要了解深拷贝与浅拷贝的概念 深拷贝、浅拷贝直接拿代码举例: 123456789101112131415161718192021222324class A {public: A(int size) : size_(size) { data_ = new int[size]; } A(){} A(const A&amp; a) { size_ = a.size_; data_ = a.data_; cout &lt;&lt; &quot;copy &quot; &lt;&lt; endl; } ~A() { delete[] data_; } int *data_; int size_;};int main() { A a(10); A b = a; cout &lt;&lt; &quot;b &quot; &lt;&lt; b.data_ &lt;&lt; endl; cout &lt;&lt; &quot;a &quot; &lt;&lt; a.data_ &lt;&lt; endl; return 0;} 上面代码中，两个输出的是相同的地址，a和b的data_指针指向了同一块内存，这就是浅拷贝，只是数据的简单赋值，那再析构时data_内存会被释放两次，导致程序出问题，这里正常会出现double free导致程序崩溃的，但是不知道为什么我自己测试程序却没有崩溃，能力有限，没搞明白，无论怎样，这样的程序肯定是有隐患的，如何消除这种隐患呢，可以使用如下深拷贝： 123456789101112131415161718192021222324class A {public: A(int size) : size_(size) { data_ = new int[size]; } A(){} A(const A&amp; a) { size_ = a.size_; data_ = new int[size_]; cout &lt;&lt; &quot;copy &quot; &lt;&lt; endl; } ~A() { delete[] data_; } int *data_; int size_;};int main() { A a(10); A b = a; cout &lt;&lt; &quot;b &quot; &lt;&lt; b.data_ &lt;&lt; endl; cout &lt;&lt; &quot;a &quot; &lt;&lt; a.data_ &lt;&lt; endl; return 0;} 深拷贝就是再拷贝对象时，如果被拷贝对象内部还有指针引用指向其它资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值。 聊完了深拷贝浅拷贝，可以聊聊移动语义啦： 移动语义，在我看来可以理解为转移所有权，之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，是通过移动构造函数。 123456789101112131415161718192021222324252627282930class A {public: A(int size) : size_(size) { data_ = new int[size]; } A(){} A(const A&amp; a) { size_ = a.size_; data_ = new int[size_]; cout &lt;&lt; &quot;copy &quot; &lt;&lt; endl; } A(A&amp;&amp; a) { this-&gt;data_ = a.data_; a.data_ = nullptr; cout &lt;&lt; &quot;move &quot; &lt;&lt; endl; } ~A() { if (data_ != nullptr) { delete[] data_; } } int *data_; int size_;};int main() { A a(10); A b = a; A c = std::move(a); // 调用移动构造函数 return 0;} 如果不使用std::move()，会有很大的拷贝代价，使用移动语义可以避免很多无用的拷贝，提供程序性能，C++所有的STL都实现了移动语义，方便我们使用。例如： 123std::vector&lt;string&gt; vecs;...std::vector&lt;string&gt; vecm = std::move(vecs); // 免去很多拷贝 注意： 移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。 5. 完美转发完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用std::forward()。 12345678910111213141516171819202122232425void PrintV(int &amp;t) { cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; endl;}void PrintV(int &amp;&amp;t) { cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; endl;}template&lt;typename T&gt;void Test(T &amp;&amp;t) { PrintV(t); PrintV(std::forward&lt;T&gt;(t)); PrintV(std::move(t));}int main() { Test(1); // lvalue rvalue rvalue int a = 1; Test(a); // lvalue lvalue rvalue Test(std::forward&lt;int&gt;(a)); // lvalue rvalue rvalue Test(std::forward&lt;int&amp;&gt;(a)); // lvalue lvalue rvalue Test(std::forward&lt;int&amp;&amp;&gt;(a)); // lvalue rvalue rvalue return 0;} 分析 Test(1)：1是右值，模板中T &amp;&amp;t这种为万能引用，右值1传到Test函数中变成了右值引用，但是调用PrintV()时候，t变成了左值，因为它变成了一个拥有名字的变量，所以打印lvalue，而PrintV(std::forward(t))时候，会进行完美转发，按照原来的类型转发，所以打印rvalue，PrintV(std::move(t))毫无疑问会打印rvalue。 Test(a)：a是左值，模板中T &amp;&amp;这种为万能引用，左值a传到Test函数中变成了左值引用，所以有代码中打印。 Test(std::forward(a))：转发为左值还是右值，依赖于T，T是左值那就转发为左值，T是右值那就转发为右值。 6. 返回值优化返回值优化(RVO)是一种C++编译优化技术，当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。 那什么时候编译器会进行返回值优化呢? return的值类型与函数的返回值类型相同 return的是一个局部对象 看几个例子: 示例1： 12345std::vector&lt;int&gt; return_vector(void) { std::vector&lt;int&gt; tmp {1,2,3,4,5}; return tmp;}std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector(); 不会触发RVO，拷贝构造了一个临时的对象，临时对象的生命周期和rval_ref绑定，等价于下面这段代码： 1const std::vector&lt;int&gt;&amp; rval_ref = return_vector(); 示例2： 123456std::vector&lt;int&gt;&amp;&amp; return_vector(void) { std::vector&lt;int&gt; tmp {1,2,3,4,5}; return std::move(tmp);}std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector(); 这段代码会造成运行时错误，因为rval_ref引用了被析构的tmp。讲道理来说这段代码是错的，但我自己运行过程中却成功了，我没有那么幸运，这里不纠结，继续向下看什么时候会触发RVO。 示例3： 123456std::vector&lt;int&gt; return_vector(void) { std::vector&lt;int&gt; tmp {1,2,3,4,5}; return std::move(tmp);}std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector(); 和示例1类似，std::move一个临时对象是没有必要的，也会忽略掉返回值优化。 最好的代码： 123456std::vector&lt;int&gt; return_vector(void) { std::vector&lt;int&gt; tmp {1,2,3,4,5}; return tmp;}std::vector&lt;int&gt; rval_ref = return_vector(); 这段代码会触发RVO，不拷贝也不移动，不生成临时对象。","link":"/2021/06/28/about-right-value/"},{"title":"跨语言通信方案：protobuf、thrift、avro","text":"常用的跨语言通信方案： 基于SOAP消息格式的WebService 基于JSON消息格式的RESTful 服务 以上两种方案的弊端： XML体积太大，解析性能极差 JSON体积相对较小，解析相对较快，但表达能力较弱 现在比较流行的跨语言通信方案： Google protobuf (http://code.google.com/p/protobuf) Apache Thrift （http://thrift.apache.org/) Apache Avro (http://avro.apache.org/) 一、方案简介thrift ： 是由 Facebook 主导开发的一个跨平台、支持多语言的，通过定义 IDL 文件，自动生成 RPC 客户端与服务端通信代码的工具，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。Thrift通过一个中间语言(IDL, 接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码并由生成的代码负责RPC协议层和传输层的实现。 protobuf： 是一种序列化与结构化数据的一种机制，具有跨平台、解析速度快、序列化数据体积小、扩展性高、使用简单的特点。 avro： 是一个二进制的数据序列化系统。实际上 Avro 除了序列化之外，像 MP 一样也提供了远程调用（ RPC ）功能。 Avro 是属于 Hadoop 的一个子项目，由 Hadoop 的 创始人 Doug Cutting 牵头开发，设计用于支持大批量数据交换的应用，依赖模式 (Schema) 来实现数据结构定义，模式由 JSON 对象来表示， Avro 也被作为一种 RPC 框架来使用。客户端希望同服务器端交互时，就需要交换双方通信的协议，它类似于模式，需要双方来定义，在 Avro 中被称为消息 (Message) 。通信双方都必须保持这种协议，以便于解析从对方发送过来的数据，这也就是传说中的握手阶段。 二、优缺点2.1 thrift应用： Facebook的开源的日志收集系统(scribe: https://github.com/facebook/scribe) 淘宝的实时数据传输平台(TimeTunnel http://code.taobao.org/p/TimeTunnel/wiki/index) Evernote开放接口(https://github.com/evernote/evernote-thrift) Quora(http://www.quora.com/Apache-Thrift) HBase( http://abloz.com/hbase/book.html#thrift ) … 优点： 支持非常多的语言绑定 thrift文件生成目标代码，简单易用 消息定义文件支持注释 数据结构与传输表现的分离，支持多种消息格式 包含完整的客户端/服务端堆栈，可快速实现RPC 支持同步和异步通信 缺点： 不支持动态特性 2.2 protobuf优点： 二进制消息，性能好/效率高（空间和时间效率都很不错） proto文件生成目标代码，简单易用 序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式) 支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级 支持多种语言（可以把proto文件看做IDL文件） Netty等一些框架集成 缺点： 官方只支持C++,JAVA和Python语言绑定 二进制可读性差（貌似提供了Text_Fromat功能） 二进制不具有自描述特性 默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持） 只涉及序列化和反序列化技术，不涉及RPC功能（类似XML或者JSON的解析器） 2.3 avro应用： Hadoop RPC（https://hadoop.apache.org/#What+Is+Apache+Hadoop） 优点： 二进制消息，性能好/效率高 使用JSON描述模式 模式和数据统一存储，消息自描述，不需要生成stub代码（支持生成IDL） RPC调用在握手阶段交换模式定义 包含完整的客户端/服务端堆栈，可快速实现RPC 支持同步和异步通信 支持动态消息 模式定义允许定义数据的排序（序列化时会遵循这个顺序） 提供了基于Jetty内核的服务基于Netty的服务 缺点： 只支持Avro自己的序列化格式 语言绑定不如Thrift丰富 三、总结protobuf适用场景： 需要和其它系统做消息交换的，对消息大小很敏感的。那么protobuf适合了，它语言无关，消息空间相对xml和json等节省很多。 小数据的场合。如果你是大数据，用它并不适合。 项目语言是c++,java,python的，因为它们可以使用google的源生类库，序列化和反序列化的效率非常高。其它的语言需要第三方或者自己写，序列化和反序列化的效率不保证。 总体而言，protobuf还是非常好用的，被很多开源系统用于数据通信的工具，在google也是核心的基础库。 其他： Thrift适用于程序对程序静态的数据交换，要求schema预知并相对固定； Avro在Thrift基础上增加了对schema动态的支持且性能上不输于Thrift； Avro显式schema设计使它更适用于搭建数据交换及存储的通用工具和平台,特别是在后台； 目前Thrift的优势在于更多的语言支持和相对成熟； PB具有跨平台、解析速度快、序列化数据体积小、扩展性高、使用简单的特点，但是内嵌并没有提供RPC的通讯。","link":"/2021/07/05/about-rpc/"},{"title":"double kill","text":"","link":"/2021/06/23/double%20kill/"},{"title":"gitlab-cicd","text":"一、准备工作1.1 准备服务器 1.2 连接到云服务器上 二、安装gitlab","link":"/2021/06/30/gitlab-cicd/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/06/22/hello-world/"},{"title":"内核态和用户态","text":"在Linux技术讨论中，常常可以听见用户态和内核态的术语，但是什么是用户态？是什么是内核态？两者之间联系是什么？两者之间的区别又是什么？为什么要有用户态和内核态的概念？ 一、什么是用户态和内核态？我们先看一张linux的整体架构图： 从图上我们可以看出来通过system call将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间），实际上我们所说的内核态就是kernel。 kernel也是一种软件程序，但是kernel比较特殊。kernel主要特殊在于kernel的功能是用来控制计算器的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供给应用程序运行。 kernel也是我们常常所说的内核态，用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫system call（系统调用）。 打个比方，可能比较好理解，如我们应用层写代码，常常使用到的创建对象实例，如Object obj = new Object();。实际上底层是通过void *malloc(size_t size);库函数进行内存分配。到malloc这里的层次依旧停留在用户态，kernel又处理不了相关的分配操作，这里就会用到系统调用的brk()和mmap()函数，通过系统调用函数就能访问到内核管理的资源。 二、为什么要有内核态和用户态的区分？在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。 如果所有的程序都能使用这些指令，那么你的系统一天死机n回就不足为奇了。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。 三、CPU特权级别Intel的CPU将特权级别分为4个级别：RING0, RING1, RING2, RING3。 Windows只使用其中的两个级别RING0和RING3，RING0只给操作系统用，RING3谁都能用。如果普通应用程序企图执行RING0指令，则Windows会显示“非法指令”错误信息。 RING0是指CPU的运行级别，RING0是最高级别，RING1次之，RING2更次之。 拿Linux+x86来说，操作系统（内核）的代码运行在最高运行级别RING0上，可以使用特权指令，控制中断、修改页表、访问设备等等。 应用程序的代码运行在最低运行级别上RING3上，不能做受控操作。如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从RING3到RING0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从RING0返回RING3。这个过程也称作用户态和内核态的切换。 举个RING权限的最简单的例子： 一个停止响应的应用程式，它运行在比RING0更低的指令环上，你不必大费周章的想着如何使系统回复运作，这期间，只需要启动任务管理器便能轻松终止它，因为它运行在比程式更低的RING0指令环中，拥有更高的权限，可以直接影响到RING0以上运行的程序，当然有利就有弊，RING保证了系统稳定运行的同时，也产生了一些十分麻烦的问题。比如一些OS虚拟化技术，在处理RING指令环时便遇到了麻烦，系统是运行在RING0指令环上的，但是虚拟的OS毕竟也是一个系统，也需要与系统相匹配的权限。而RING0不允许出现多个OS同时运行在上面，最早的解决办法便是使用虚拟机，把OS当成一个程序来运行。 四、内核调用架构图 通过上图可以发现，内核控制并且管理硬件资源，包括进程的调度和管理、内存管理、文件系统管理、设备驱动管理、网络管理等等。并且提供应用程序统一的系统调用接口。这种分层的架构，极大的提升了系统的稳定性和扩展性，兼容性。 五、用户态和内核态的切换那么问题又来了，从用户态到内核态到底怎么进入？只能通过系统调用吗？还有其他方式吗？ 从用户态到内核态切换可以通过三种方式： 系统调用，这个上面已经讲解过了，在我公众号之前的文章也有讲解过。其实系统调用本身就是中断，但是软件中断，跟硬中断不同。 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 我们常常讨论的时候，就会说内核态的切换比较耗时，耗时的原因是什么呢？ Linux下每个进程的栈有两个，一个是用户态栈，一个是内核态栈。在需要从用户态栈切换到内核的时候，需要进行执行栈的转换，保存用户态的状态，包括寄存器状态，然后执行内核态操作，操作完成后要恢复现场，切换到用户态，这个过程是耗时的。这是宏观上看到的东西，还有很多细节值得大家去研究。 最后附上一张详细些的kernel架构图，便于对照学习。","link":"/2021/06/23/kernelspace-usersapce/"},{"title":"Linux文件系统","text":"在 Linux 系统中一切皆文件，除了通常所说的狭义的文件以外，目录、设备、套接字和管道等都是文件。 文件系统在不同的上下文中有不同的含义： 在存储设备上组织文件的方法，包括数据结构和访问方法，到存储设备。 按照某种文件系统类型格式化的一块存储介质。我们常说在某个目录下挂载或卸载文件系统， 这里的文件系统就是这种意思。 内核中负责管理和存储文件的模块，即文件系统模块。 一、文件系统架构图Linux文件系统的架构如下图所示，分为用户空间、内核空间和硬件3个层面：","link":"/2021/07/07/linux-fs/"},{"title":"mysql cluster","text":"集群（cluster）技术是一种较新的技术，通过集群技术，可以在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益，其任务调度则是集群系统中的核心技术。 集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。集群配置是用于提高可用性和可缩放性。 一、集群概念在我们讨论mysql主从复制之前，我们先要清楚一个集群的概念。那什么是集群？ 集群（cluster）技术是一种较新的技术，通过集群技术，可以在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益，其任务调度则是集群系统中的核心技术。 集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。集群配置是用于提高可用性和可缩放性。 简单的讲，集群是指同一种组件的多个实例，形成的逻辑上的整体。 而容易与其混淆的概念分布式，是指通过网络连接的多个组件，通过交换信息协作而形成的系统。 二、MYSQL集群MySQL集群是一个无共享的(shared-nothing)、分布式节点架构的存储方案，其目的是提供容错性和高性能。 数据更新使用读已提交隔离级别（read-committedisolation)来保证所有节点数据的一致性，使用两阶段提交机制（two-phasedcommit)保证所有节点都有相同的数据(如果任何一个写操作失败，则更新失败）。 无共享的对等节点使得某台服务器上的更新操作在其他服务器上立即可见。传播更新使用一种复杂的通信机制，这一机制专用来提供跨网络的高吞吐量。 通过多个MySQL服务器分配负载，从而最大程序地达到高性能，通过在不同位置存储数据保证高可用性和冗余。 优点： 高可用性 快速的自动失效切换 灵活的分布式体系结构，没有单点故障 高吞吐量和低延迟 可扩展性强，支持在线扩容 缺点： 存在很多限制，比如：不支持外键 部署、管理、配置很复杂 占用磁盘空间大，内存大 备份和恢复不方便 重启的时候，数据节点将数据加载到内存需要很长时间 三、集群方案 主从架构：只是有数据备份的功能； 主主互备+keepalived：实现数据备份加高可用； 主主互备，主主下面分别挂个从； A和B主主互备，把从库都挂到B下，减少IO问题； MMM架构，perl编写，基于mysql主从复制，成熟高可用集群方案，由一个管理端(monitor)和多个代理端（aget）构成 优点：监控所有Master节点及Slave节点状态，当master节点出现故障，会把vip自动转移到健康节点上；更重要的是当Master节点发生故障，会自动将后端Slave节点转向备用的Master节点继续同步复制，切换过程不需要人工干预； 缺点：对ip，服务器数量有要求(至少两台服务器，2个真实ip，3个vip)；业务繁忙，数据量大的时候不是很稳定，会出现复制延时，切换失效等问题；所以MMM方案不适合应用于对数据安全性要求很高，并读写频繁的环境中。数据量大的时候，会有主从数据不同步的问题； MHA架构，搭建起来比较麻烦，至少三台机器，淘宝进行过二次开发，可以用两台机器； 读写分离中间件： mysqlproxy：通过lua脚本实现的读写分离，不太稳定，官网不建议用； Amoeba：致力于mysql分布式数据库前端代理层，它主要在应用层，访问mysql的时候充当SQL路由器的功能，依据用户事先设置的规则，将SQL请求发送到特定的数据库上执行。基于此可以实现负载均衡、读写分离、高可用性等需求。Amoeba相当于一个SQL请求的路由器，目的是为负载均衡、读写分离、高可用性提供机制，而不是完全实现它们。 四、数据存储Mysqlcluster数据节点组内主从同步采用的是同步复制，来保证组内节点数据的一致性。一般通过两阶段提交协议来实现，一般工作过程如下： Master执行提交语句时，事务被发送到slave，slave开始准备事务的提交。 每个slave都要准备事务，然后向master发送OK(或ABORT)消息，表明事务已经准备好（或者无法准备该事务）。 Master等待所有Slave发送OK或ABORT消息 如果Master收到所有Slave的OK消息，它就会向所有Slave发送提交消息，告诉Slave提交该事务； 如果Master收到来自任何一个Slave的ABORT消息，它就向所有 Slave发送ABORT消息，告诉Slave去中止事务。 每个Slave等待来自Master的OK或ABORT消息。 如果Slave收到提交请求，它们就会提交事务，并向Master发送事务已提交的确认； 如果Slave收到取消请求,它们就会撤销所有改变并释放所占有的资源，从而中止事务，然后向Masterv送事务已中止的确认。 当Master收到来自所有Slave的确认后，就会报告该事务被提交（或中止），然后继续进行下一个事务处理。 由于同步复制一共需要4次消息传递，故mysql cluster的数据更新速度比单机mysql要慢。所以mysql cluster要求运行在千兆以上的局域网内，节点可以采用双网卡，节点组之间采用直连方式。 Mysqlcluster将所有的索引列都保存在主存中，其他非索引列可以存储在内存中或者通过建立表空间存储到磁盘上。如果数据发生改变(insert, update, delete等)，mysql 集群将发生改变的记录写入重做日志，然后通过检查点定期将数据定入磁盘。由于重做日志是异步提交的，所以故障期间可能有少量事务丢失。为了减少事务丢失，mysql集群实现延迟写入(默认延迟两秒，可配置)，这样就可以在故障发生时完成检查点写入，而不会丢失最后一个检查点。一般单个数据节点故障不会导致任何数据丢失，因为集群内部采用同步数据复制。 五、MYSQL主从复制5.1 什么是主从复制？指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。MySQL主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。一句话表示就是，主数据库做什么，从数据库就跟着做什么。 5.2 主从同步方式tips：Mysql binlog是二进制日志文件，用于记录mysql的数据更新或者潜在更新(比如DELETE语句执行删除而实际并没有符合条件的数据)，在mysql主从复制中就是依靠的binlog。 5.2.1 STATEMENT模式（SBR） 基于语句的复制：主库把sql语句写入到bin log中，完成复制 每一条会修改数据的sql语句会记录到binlog中。优点是并不需要记录每一条sql语句和每一行的数据变化，减少了binlog日志量，节约IO，提高性能。缺点是在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题) 5.2.2 ROW模式（RBR） 基于行数据的复制：主库把每一行数据变化的信息作为事件，写入到bin log，完成复制 不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是alter table的时候会让日志暴涨。 5.2.3 MIXED模式（MBR） 混合复制：上面两个结合体，默认用语句复制，出问题时候自动切换成行数据复制 以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。 5.3 主从复制工作原理剖析 Master 数据库只要发生变化，立马记录到Binary log 日志文件中 Slave数据库启动一个I/O thread连接Master数据库，请求Master变化的二进制日志 Slave I/O获取到的二进制日志，保存到自己的Relay log 日志文件中 Slave 有一个 SQL thread定时检查Realy log是否变化，变化那么就更新数据 5.4 为什么要用mysql 的主从？ 实现服务器负载均衡 即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好的客户相应时间。通常情况下，数据库管理员会有两种思路。 一是在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部 转发到从服务器中。这在某些应用中会比较有用。如某些应用，像基金净值预测的网站。其数据的更新都是有管理员更新的，即更新的用户比较少。而查询的用户数 量会非常的多。此时就可以设置一台主服务器，专门用来数据的更新。同时设置多台从服务器，用来负责用户信息的查询 二是在主服务器上与从服务器切分查询的作业。在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。 通过复制实现数据的异地备份 可以定期的将数据从主服务器上复制到从服务器上，这无疑是先了数据的异地备份。在传统的备份体制下，是将数据备份在本地。此时备份 作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也 不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。这显然会给企业 带来比较大的损失。 提高数据库系统的可用性 数据库复制功能实现了主服务器与从服务器之间数据的同步，增加了数据库系统的可用性。当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。然后回过头来再仔细的检查主服务器的问题。此时一般数据库管理员也会采用两种手段。 一是主服务器故障之后，虽然从服务器取代了主服务器的位置，但是对于主服务器可以采取的操作仍然做了一些限制。如仍然只能够进行数据的查询，而 不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。如现在一些银行系统的升级，在升级的过程中，只能够查询余额而不能够取钱。这是同样的道 理。 二是从服务器真正变成了主服务器。当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操 作。为此就需要做好数据的安全性工作。即数据的安全策略，要与原先的主服务器完全相同。否则的话，就可能会留下一定的安全隐患 参考链接：https://www.cnblogs.com/wuxu/p/13161438.htmlhttps://blog.csdn.net/qq_21153619/article/details/81529880https://www.jianshu.com/p/19cb0f16dea4","link":"/2021/06/29/mysql-cluster/"},{"title":"Java 最常见的 208 道面试题","text":"Java 最常见的 208 道面试题答案：https://zhuanlan.zhihu.com/p/64147696 一、网络相关1.1 TCP相关 参考链接：https://mp.weixin.qq.com/s/044UVaCinUdGbof-SI-3XA 能不能说一说 TCP 和 UDP 的区别？ 说说TCP三次握手的过程？为什么是三次而不是两次、四次？ 说说TCP四次挥手的过程 说说半连接队列和SYN Flood攻击的关系 介绍一下 TCP 报文头部的字段 说一下 tcp 粘包是怎么产生的？有什么办法可以解决？ 能不能说一说 TCP 的流量控制？ 能不能说说 TCP 的拥塞控制？ TCP的超时重传时间是如何计算的？ 说说 TCP 快速打开的原理(TFO) 能不能说说TCP报文中时间戳的作用？ 能不能说说 Nagle 算法和延迟确认？ 如何理解 TCP 的 keep-alive？ 1.2 HTTP相关 说说http数据格式的组成？ 能不能说说cookie和session的区别和关系？ 能不能说说http和https的区别？为什么https更安全？ 说说你了解http的常见状态码，并说说分别代表什么意思？ 你知道http的队头阻塞问题吗？说说你理解的队头阻塞问题。如何解决队头阻塞？ 二、数据库相关2.1 mysql 你对mysql存储结构了解多少？说一说。 你知道innodb存储是什么实现的？B+树是什么？B+树和B树的区别是什么？ 你知道mysql中的锁吗？行级锁和表级锁的区别是什么？ 你知道mysql事务是什么吗？事务有哪些隔离级别？ 你发现一条sql执行得很忙，你打算怎么对这条sql进行优化？ 你知道mysql的redo log和undo log吗？分别说一下在什么情况下使用？有什么区别？ 你知道mysql的主从同步是怎么实现的呢？如何解决主从同步的时延问题？ 2.2 redis https://mp.weixin.qq.com/s/5wAp844dUrV5djCcJzZipg 你知道为什么需要使用缓存？ 你知道memcache和redis的区别吗？说一说。 你知道为什么redis能这么快？ 说一说redis的数据类型？你常常使用哪些数据类型？ 你知道如何通过redis实现分布式锁？ 你知道如何通过redis实现异步队列？ 你知道redis的持久化吗？持久化的步骤是怎样的呢？ 你知道redis的数据如何进行恢复吗? 说一说你了解的redis哨兵机制。 你知道redis的同步机制吗？大致流程是怎样的呢？ 你知道redis集群如何实现吗？一致性hash是什么？如何解决数据倾斜问题？ 你知道缓存雪崩、缓存穿透、缓存击穿分别是什么吗？如何解决呢？ 三、操作系统3.1 操作系统基础 你知道进程和线程的区别吗? 你知道堆和栈的区别吗？ 你知道并发和并行的区别吗？ 你知道死锁会在什么情况下出现吗？如何解决死锁问题？ 你知道内存泄露和内存溢出的区别吗？两个有没有什么关系? 你知道孤儿进程、僵尸进程和守护进程的区别吗? 3.2 Linux top命令、ps命令、netstat命令、awk命令、find命令、grep命令、wc命令、sed命令、head命令和tail命令。 如何查找出现频率最高的100个IP地址 如何统计文件中某个字符串出现的频率 linux启动的第一个进程 linux查看端口占用 linux查看cpu和内存使用 linux查看系统负载命令 linux软链接和硬链接 shell脚本基本语法和使用 四、算法和数据结构4.1 常见排序算法 冒泡排序法 插入排序法 选择排序法 快速排序法*&amp;快速排序优化* 归并排序法 希尔排序法 堆排序法 桶排序法 基数排序法 计数排序法 4.2 常见非排序算法 字符串操作 数组操作 递归 回溯法 二分搜索法 分治法 动态规划 4.3 常用数据结构 链表（单向链表、双向链表） 栈 队列 树（二叉树、平衡二叉树） 堆（大顶堆、小顶堆） 五、JAVA基础 https://blog.csdn.net/sufu1065/article/details/88051083 5.1 语言基础 JDK 和 JRE 有什么区别？ == 和 equals 的区别是什么？ 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ final 在 java 中有什么作用？ java 中的 Math.round(-1.5) 等于多少？ String 属于基础的数据类型吗？ java 中操作字符串都有哪些类？它们之间有什么区别？ String str=”i”与 String str=new String(“i”)一样吗？ 如何将字符串反转？ String 类的常用方法都有那些？ 抽象类必须要有抽象方法吗？ 普通类和抽象类有哪些区别？ 抽象类能使用 final 修饰吗？ 接口和抽象类有什么区别？ java 中 IO 流分为几种？ BIO、NIO、AIO 有什么区别？ Files的常用方法都有哪些？ 5.2 容器相关 java 容器都有哪些？ Collection 和 Collections 有什么区别？ List、Set、Map 之间的区别是什么？ HashMap 和 Hashtable 有什么区别？ 如何决定使用 HashMap 还是 TreeMap？ 说一下 HashMap 的实现原理？ 说一下 HashSet 的实现原理？ ArrayList 和 LinkedList 的区别是什么？ 如何实现数组和 List 之间的转换？ ArrayList 和 Vector 的区别是什么？ Array 和 ArrayList 有何区别？ 在 Queue 中 poll()和 remove()有什么区别？ 哪些集合类是线程安全的？ 迭代器 Iterator 是什么？ Iterator 怎么使用？有什么特点？ Iterator 和 ListIterator 有什么区别？ 怎么确保一个集合不能被修改？ 5.3 多线程相关 并行和并发有什么区别？ 线程和进程的区别？ 守护线程是什么？ 创建线程有哪几种方式？ 说一下 runnable 和 callable 有什么区别？ 线程有哪些状态？ sleep() 和 wait() 有什么区别？ notify()和 notifyAll()有什么区别？ 线程的 run()和 start()有什么区别？ 创建线程池有哪几种方式？ 线程池都有哪些状态？ 线程池中 submit()和 execute()方法有什么区别？ 在 java 程序中怎么保证多线程的运行安全？ 多线程锁的升级原理是什么？ 什么是死锁？ 怎么防止死锁？ ThreadLocal 是什么？有哪些使用场景？ 说一下 synchronized 底层实现原理？ synchronized 和 volatile 的区别是什么？ synchronized 和 Lock 有什么区别？ synchronized 和 ReentrantLock 区别是什么？ 说一下 atomic 的原理？ 5.4 反射 什么是反射？ 什么是 java 序列化？什么情况下需要序列化？ 动态代理是什么？有哪些应用？ 怎么实现动态代理？ 5.5 对象拷贝 为什么要使用克隆？ 如何实现对象克隆？ 深拷贝和浅拷贝区别是什么？ 5.6 Java Web session 和 cookie 有什么区别？ 说一下 session 的工作原理？ 如果客户端禁止 cookie 能实现 session 还能用吗？ spring mvc 和 struts 的区别是什么？ 你知道什么是sql注入吗？如何避免 sql 注入？ 什么是 XSS 攻击，如何避免？ 什么是 CSRF 攻击，如何避免？ 5.7 异常 throw 和 throws 的区别？ final、finally、finalize 有什么区别？ try-catch-finally 中哪个部分可以省略？ try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？ 常见的异常类有哪些？ 5.8 设计模式 说一下你熟悉的设计模式？ 简单工厂和抽象工厂有什么区别？ 5.9 Spring/Spring MVC 为什么要使用 spring？ 解释一下什么是 aop？ 解释一下什么是 ioc？ spring 有哪些主要模块？ spring 常用的注入方式有哪些？ spring 中的 bean 是线程安全的吗？ spring 支持几种 bean 的作用域？ spring 自动装配 bean 有哪些方式？ spring 事务实现方式有哪些？ 说一下 spring 的事务隔离？ 说一下 spring mvc 运行流程？ spring mvc 有哪些组件？ @RequestMapping 的作用是什么？ @Autowired 的作用是什么？ 5.10 Spring Boot/Cloud 什么是 spring boot？ 为什么要用 spring boot？ spring boot 核心配置文件是什么？ spring boot 配置文件有哪几种类型？它们有什么区别？ spring boot 有哪些方式可以实现热部署？ jpa 和 hibernate 有什么区别？ 什么是 spring cloud？ spring cloud 断路器的作用是什么？ spring cloud 的核心组件有哪些？ 5.11 Hibernate 为什么要使用 hibernate？ 什么是 ORM 框架？ hibernate 中如何在控制台查看打印的 sql 语句？ hibernate 有几种查询方式？ hibernate 实体类可以被定义为 final 吗？ 在 hibernate 中使用 Integer 和 int 做映射有什么区别？ hibernate 是如何工作的？ get()和 load()的区别？ 说一下 hibernate 的缓存机制？ hibernate 对象有哪些状态？ 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？ hibernate 实体类必须要有无参构造函数吗？为什么？ 5.12 Mybatis mybatis 中 #{}和 ${}的区别是什么？ mybatis 有几种分页方式？ RowBounds 是一次性查询全部结果吗？为什么？ mybatis 逻辑分页和物理分页的区别是什么？ mybatis 是否支持延迟加载？延迟加载的原理是什么？ 说一下 mybatis 的一级缓存和二级缓存？ mybatis 和 hibernate 的区别有哪些？ mybatis 有哪些执行器（Executor）？ mybatis 分页插件的实现原理是什么？ mybatis 如何编写一个自定义插件？ 5.13 JVM 说一下 jvm 的主要组成部分？及其作用？ 说一下 jvm 运行时数据区？ 说一下堆栈的区别？ 队列和栈是什么？有什么区别？ 什么是双亲委派模型？ 说一下类加载的执行过程？ 怎么判断对象是否可以被回收？ java 中都有哪些引用类型？ 说一下 jvm 有哪些垃圾回收算法？ 说一下 jvm 有哪些垃圾回收器？ 详细介绍一下 CMS 垃圾回收器？ 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？ 简述分代垃圾回收器是怎么工作的？ 说一下 jvm 调优的工具？ 常用的 jvm 调优的参数都有哪些？ 六、中间件 https://blog.csdn.net/sufu1065/article/details/88051083 6.1 RabbitMQ rabbitmq 的使用场景有哪些？ rabbitmq 有哪些重要的角色？ rabbitmq 有哪些重要的组件？ rabbitmq 中 vhost 的作用是什么？ rabbitmq 的消息是怎么发送的？ rabbitmq 怎么保证消息的稳定性？ rabbitmq 怎么避免消息丢失？ 要保证消息持久化成功的条件有哪些？ rabbitmq 持久化有什么缺点？ rabbitmq 有几种广播类型？ rabbitmq 怎么实现延迟消息队列？ rabbitmq 集群有什么用？ rabbitmq 节点的类型有哪些？ rabbitmq 集群搭建需要注意哪些问题？ rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？ rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？ rabbitmq 对集群节点停止顺序有要求吗？ 6.2 Kafka kafka 可以脱离 zookeeper 单独使用吗？为什么？ kafka 有几种数据保留的策略？ kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？ 什么情况会导致 kafka 运行变慢？ 使用 kafka 集群需要注意什么？ 6.3 Zookeeper zookeeper 是什么？ zookeeper 都有哪些功能？ zookeeper 有几种部署模式？ zookeeper 怎么保证主从节点的状态同步？ 集群中为什么要有主节点？ 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？ 说一下 zookeeper 的通知机制？ 七、其他Java 最常见的 208 道面试题答案：https://zhuanlan.zhihu.com/p/64147696","link":"/2021/06/28/no-work/"},{"title":"指针和内存之间的关系","text":"指针和内存之间的关系 内存模型图在每个进程运行时都会申请4G的虚拟内存（32位CPU，32位操作系统，x86体系），如图所示。 指令和数据数据可读、可写、不可执行，指令可读、不可写、可执行。两者存放在不同的位置。 代码示例1234567891011121314151617181920#include &lt;stdio.h&gt;int gdata1 = 10; //.dataint gdata2 = 0; //.bssint gdata3; //.bss段进程运行时，操作系统为.bss初始化为0static int gdata4 = 11; //.datastatic int gdata5 = 0; //.bssstatic int gdata6; //.bssint main(){ char *p = “hello world”; //.rodata区 *p = ‘a’; //崩溃,不可写 int a = 12; //data int b = 0; //.bss int c; //随机值、无效值.bss static int d = 13; //.data static int e = 0; //.bss static int f; //.bss,初始化为0 return 0;} 虚拟内存我们一般编程所说的内存是虚拟内存。 我们编程提到的内存都是抽象的概念，是虚拟的内存，并不是实在的物理内存。物理内存就是我们看得到摸得着的内存条。而我们需要了解的就是虚拟内存。出了写驱动等级别的程序外，一般是不需要了解具体的内存的，操作系统会将虚拟内存转换成物理内存。 虚拟内存是进程所在的地址空间。 虚拟内存是给每一个进程的一个内存空间。每一个进程都有一个虚拟内存空间，进程之间的虚拟内存是隔绝的，相互不能重叠。 而虚拟内存的大小则是根据操作系统的位数来决定的，比如32位操作系统，则虚拟内存大小为2的32次方。这个通常叫做进程的地址空间。 如果进程间需要通信，则需要通过进程间通信（IPC）来实现。这是虚拟内存的一个补充机制。 虚拟内存内存是线性的。物理内存的实现，和具体的内存品牌公司的策略有关。实际的物理内存很多都不是线性排开的，但是通过内存机制，对外展示成线性的逻辑地址，即从0一直到最大地址。而这个逻辑的内存模型，则表现在系统中的虚拟内存则是在此基础上的进一步的抽象。不过，只要记住一点，虚拟内存是线性的。线性即表示在一条线上就可以表示所有的地址，而不需要通过几个层次结构来定位一个内存地址。 内存与指针的关系 指针是一个类型，占用的字节数与操作系统的位数有关。而操作系统的位数，决定虚拟内存的大小。如果是32位，则虚拟内存地址就是2的32次方个字节；如果是64则虚拟内存地址就是2的64个字节。 而这么大的地址，需要指针能够全部索引到。所以，指针的值必须能够表示这么多个数字，而在32位操作系统中，则指针的值需要能够表示2的32次方个数，那么需要的就是32位的内存，即4字节。所以在32位系统中，指针只要是4字节就够了。不管是什么类型的指针，都是4字节。而在64位系统中，需要64位的指针，即8字节的指针。这4字节或者8字节就是必需的大小。 如果指针超过这个需要的值，纯粹是浪费，如果小于这个需要的值，则不能够所引到内存的后面的部分。这也是，32位操作系统支持的最大内存是4GB，多了指针无法索引到，也就无法操作大于4GB内存位置。 然后，内存地址是什么？内存地址，由上图可以看出，内存地址就是内存单元的编号而已。最后，变量就是一定大小的内存块，而变量名就是一个符号，由编译器处理，然后将内存块映射到变量。因此对变量的操作其实就是对对应的内存块的操作。","link":"/2021/06/28/pointer-memory/"},{"title":"指针和内存之间的关系","text":"指针和引用的概念 指针和引用主要有以下区别： 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。 引用初始化后不能被改变，指针az可以改变所指的对象。 不存在指向空值的引用，但是存在指向空值的指针。 从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。 而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。 在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的： 指针传递参数本质上是 值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的 实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。 而在引用传递过程中， 被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间 接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 引用传递和指针传递是 不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针 传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的 指针，或者指针引用。 最后，总结一下指针和引用的相同点和不同点： 相同点： 都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。 不同点： 指针是一个实体，而引用仅是个别名； 引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”； 引用没有const，指针有const，const的指针不可变； 引用不能为空，指针可以为空； “sizeof(引用)” 得到的是所指向的变量(对象)的大小，而“sizeof(指针)” 得到的是指针本身的大小； 指针和引用的自增(++)运算意义不一样； 引用是类型安全的，而指针不是 (引用比指针多了类型检查） 虽然使用引用和指针都可以间接访问另一个值，但他们之间有两个重要区别： 引用总是指向某个对象，定义引用没有初始化是错误的。 赋值行为的差异，给引用赋值修改的是该引用所关联的对象的值，而并不是使引用与另一个对象关联。引用一经初始化，就始终指向同一个特定对象。","link":"/2021/06/28/pointer-reference/"},{"title":"程序的编译过程","text":"程序的编译过程 一、编译把文本形式的源代码翻译成机器语言，并形成目标文件，该阶段又可以细分为三个小的阶段。 1) 编译预处理预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如#include），这个过程会得到不包含#指令的.i文件。 这个过程会拷贝#include 包含的文件代码，进行#define 宏定义的替换 ， 处理条件编译指令 （#ifndef、#ifdef、#endif）等。 2) 编译优化通过预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。 这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。这个过程将.i文件转化位.s文件。 3) 汇编汇编过程就是把汇编语言翻译成目标机器指令的过程，生成目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。 目标文件由段组成，通常至少有两个段： 代码段：包换主要程序的指令。该段是可读和可执行的，一般不可写 数据段：存放程序用到的全局变量或静态数据。可读、可写、可执行。 这个过程将.s文件转化成.o文件。 二、连接把目标文件操作系统的启动代码和库文件组织起来形成可执行程序。原因： 某个源文件调用了另一个源文件中的函数或常量 在程序中调用了某个库文件中的函数 链接程序的主要工作就是将有关的目标文件连接起来。这个过程将.o文件转化成可执行的文件。 三、总结123456789graph LR code(源代码.c/.cpp) --&gt; compile&gt;编译器] compile --&gt; ass(汇编代码.s) ass --&gt; asss&gt;汇编器] asss --&gt; res_code(目标代码.o) other_code(其他目标代码) --&gt; links&gt;链接器] res_code --&gt; links lib_file(库文件) --&gt; links links --&gt; exe(可执行文件)","link":"/2021/06/28/program-compilation/"},{"title":"软件测试工程师技术图谱","text":"一个优秀的软件测试工程师应该具备扎实的基本技能、逆向思维的能力、敏锐的洞察力、锲而不舍的精神、发散性的思维以及良好的沟通能力。 一、技能1.1 常见招聘要求 熟练使用java/c#/python/c++中至少一种语言，熟悉Mysql/Oracle/SQL server/DB2中至少一种关系型数据库。 熟悉Linux操作系统、熟悉网络、熟悉网页相关知识。 熟悉软件工程和CMMI体系，精通测试理论及测试用例设计、白盒黑盒测试方法。 熟悉性能测试工具，如bps、loadrunner、ixia、jemeter等。 具有良好的文档测试以及编写能力，可熟练搭建测试环境。 熟悉接口自动化、UI自动化等。 熟悉常用的测试工具（Selenium、Jmeter、postman）及测试框架（RF、unittest、testng、cucnumber）。 具有Web端自动化测试经验，熟悉常见测试方法（UIautomentor、Appium、Selenium、TestNG）的原理和使用方法。 具有实现软件持续集成相关经验，熟悉持续集成相关流程、技术、工具（git、jenkins）。 优先考虑： 有自动化测试工具开发维护经验 有成功的大规模自动化测试实施经验 具有数据测试经验 了解敏捷开发流程 能够独立搭建CI/CD流水线者 有敏捷测试scrum matser经验者 1.2 关键词 二、技能点2.1 通用技能2.2 测试技能2.2.1 测试方法/测试技能 自动化测试 测试用例 测试工具 性能测试 测试流程 测试报告 功能测试 接口测试 2.3 项目相关2.3.1 项目描述2.3.1.1 洲明会议系统2.3.1.2 工具矩阵2.3.1.3 Launcher2.3.2 项目问题 在项目中你负责的部分是什么呢？ 在项目中有用到自动化吗？ 自动化用的什么框架？ 整个自动化平台是你搭建起来的吗？ 你们的项目为什么要做自动化？ 自动化给你们带来了哪些收益？ 你们的自动化覆盖率大概有多少呢？ 自动化测试的时候产生误报怎么处理呢？ 自动化代码中，有用到哪些设计模式呢？ 2.3.3 项目管理2.3.3.1 瀑布 2.3.3.2 敏捷三、非技能点3.1 自我介绍 例： 我叫xx, 3.2 非技能问题 你的职业规划是什么？ 你觉得在项目中你最自豪的一件事是什么？ 你觉得你的优点/缺点是什么？ 在同事的眼中，你是一个什么样的人？ 你觉得你跟别人最大的不同在于哪里呢？ 你对我们公司了解有多少？ 你为什么想离职？ 你找工作时，最重要的考虑因素为何？ 在原来的单位主要做什么工作的？ 对工资的期望是多少？ 我没有什么要问的了，你有什么问题问我吗？","link":"/2021/06/30/software-test/"},{"title":"面试中的mysql常见问题","text":"数据库是后端程序员面试必不可少的一个技能，mysql作为开源、免费、简易部署、应用广，常常在面试中被问到。整理一些面试会经常被问到的问题，便于复习查阅。 1. mysql存储引擎了解多少？常见的mysql存储引擎有InnoDB和MyISAM。 其中InnoDB是行级锁，MyISAM是表级锁，所以InnoDB的并发更高 其中InnoDB支持事务，MyISAM不支持事务 其中InnoDB支持外键，MyISAM不支持外键 其中InnoDB有完整的容灾备份系统，支持在线热备Tumy 其中统计行数用MyISAM更快，MyISAM查询更快。InnoDB增、删、修比较快 2. mysql的存储方式是怎么样的呢？InnoDB的索引是B+Tree的结构，B+Tree每个节点最多有m个子节点，只有叶子节点存储数据，每个叶子节点的数据与下一个叶子节点有一个指针指向。 3. mysql如何优化sql查询？ 对于查询尽量走索引 应该尽量避免全局扫描。如：in、not in、like、where中使用or、where中使用参数、where中使用!=和&lt;&gt;。 4. mysql的事务？事务有哪些隔离级别？mysql的事务隔离级别由低到高分别为：读未提交（脏读、不可重复读、幻读），读已提交（不可重复读、幻读），可重复读（幻读），串行化。 5. 大量请求都是写数据，如何存储？存储数据太多，怎么处理？使用InnoDB存储引擎；分库分表。 6. 数据库事务的特性是什么？ACID。原子性，一致性，隔离性，持久性。 7. mysql索引中的BTree和B+Tree的区别 BTree和B+Tree都是m阶树，其中BTree是通过每个节点存储数据，B+Tree是通过叶子节点存储数据，且相邻叶子节点的数据前后都有指针相连 其中B+Tree的磁盘读写代价比BTree低 B+Tree的查询比BTree更稳定 8. mysql如何创建索引？ 某些字段需要频繁用作查询条件时需要为它建立索引 唯一性太差的字段不适合建立索引 更新太频繁的字段不适合建立索引 不会出现的where语句中的字段不适合建立索引 9. mysql索引有几种？时间复杂度如何？ 从数据结构角度 B+树索引(O(log(n))) hash索引 FULLTEXT索引 R-Tree索引 从物理存储角度 聚集索引 非聚集索引 从逻辑角度 主键索引：主键索引是一种特殊的唯一索引，不允许有空值 普通索引或者单列索引 多列索引（复合索引） 唯一索引或者非唯一索引 空间索引 10. 你了解密集索引和稀疏索引吗？密集索引：文件中的每个搜索码值都对应一个索引值,就是叶子节点保存了整行, innodb只有一个 稀疏索引：文件只为索引码的某些值建立索引项, 比如 innodb的其他索引只存了键位信息和主键, myisam的所有索引都是 MyISAM：不管是主键索引、唯一键索引或者普通索引，其索引都属于稀疏索引 InnoDB： 若一个主键被定义，该主键则作为密集索引 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引） 非主键索引（稀疏索引）存储相关键位和它对应的主键值，包含两次查找 11. mysql的高可用方案有哪些呢？最常见的就是Mysql主从架构。一个master，多个salves。其他自己百度，不是数据库专家，没必要掌握太多。 12. 数据库中的索引有什么用？索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。 13. 如何查看sql语句中有没有使用索引？可以在查询的sql前面增加explain命令，以此可以查看到sql的运行状态。查看结果中的type列和extra列。 如果extra列值为Using filesort和Using temproary，则表示这条sql写得贼垃圾，赶紧优化 如果type列为index和all的时候，表示sql走的全表扫描，还不调优就是沙雕了 如果type列为index或ref的时候，表示走了索引。其中index走的是非重复值的索引，ref的索引是存在重复值的。ref会比index性能差一丢丢，但影响不大，可以不用再优化了 14. 怎么在语句中强制使用其他的索引？force index(other_key) 15. like的索引机制？like只对%在后面的字段走索引。如：like 'aa%'；但是对%在中间或者前面的情况不走索引，如：like '%aa'或者like 'a%a'。 16. mysql的同步机制是什么？ 主库会开启一个IO线程，从服务器会开启一个IO线程和一个SQL线程。 从服务器通过IO进程读取主库的binlog，写入到relay_log中，从服务器通过sql running进程读取从库的relay_log，并写入到从库的bin_Log实现同步。 17. sql的慢查询优化怎么做？ 开启慢查询日志。SET GLOBAL slow_query_log = 'ON' 对日志中查询较慢的sql进行explain查看sql是否使用了索引。explain sql 18. InnoDB的事务是用的哪种？默认是RR（可重复读）。解决了不可重复读问题，没有解决幻读。 19. 不可重复读与幻读的区别在于？ 在RC（读已提交）级别下，会出现不可重复读，表示对某一行的数据前后读取内容不一致。 在RR（可重复读）级别下，不会出现不可重复读，保证对每一行的数据在整个事务中的内容是一样的，但是如果实在做统计查询或者批量查询的时候，会导致出现幻读（查询行数不一致）。 RC针对某一行出现前后不一致，RR针对批量操作出现前后不一致。RR出现幻读，可以尝试通过间隙锁解决问题。 20. InnoDB的redo log和undo log是什么？redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。 它们都是用来恢复的日志： redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。 undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。 innodb存储引擎中，redo log以块为单位进行存储的，每个块占512字节，这称为redo log block。 innodb存储引擎对undo的管理采用段的方式。rollback segment称为回滚段，每个回滚段中有1024个undo log segment。 简而言之，redo log是可以在异常情况下（buffer pool已修改，但磁盘未修改就崩溃了），将buffer pool中的数据写入磁盘中；undo log是记录修改前的值，用来回滚。 21. 如何解决mysql 主从同步的时延问题？我们知道生产环境中经常会遇到MySQL主从延迟问题，从原理上也能看出主库的事务提交是并发模式，而从库只有一个SQL线程负责解析，所以本身上就可能存在延迟。 延迟的主要原因在于： 从库的配置往往没有主库的配置高 主库支持并发写入，而5.7之前的版本上从库只有单线程SQL来完成任务 MySQL主从之间的同步，并不是完全的实时同步，而是主库提交事务之后，从库才再来执行一遍 主库上的表的某个列没有索引，然后对这个列进行delete或update操作 网络问题，往返时延RTT较大 解决方案如下： 使用MySQL5.7以上版本，MySQL5.7版本后引入新的机制，即基于组提交的并行复制 可以采用percona公司的PXC架构，实现多节点写入，达到时时同步 在业务初期就选择合适的分库、分表策略，避免单表单库过大带来额外的复制压力 避免一些无用的I/O消耗，使用PCIE-SSD硬盘 磁盘阵列选择RAID10架构，raid cache策略使用WB而非WT 适当调整buffer pool的大小 避免数据库进行各种大量的运算 22. 数据库的范式有哪些？共六种，记住前三种就可以了。 第一范式：每一列都是不可以再拆分的 第二范式：非主键完全依赖于主键，而不依赖于主键的部分 第三范式：非主键完全只依赖于主键，而不依赖于其他非主键 23. mysql的binlog的录入方式有哪些，有什么区别？ statement level模式 每一条会修改数据的sql都会记录到master的bin-log中。slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql来再次执行。 rowlevel模式 日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改 mixed模式 实际上就是前两种模式的结合，在mixed模式下，mysql会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在statement和row之间选一种。 24. MyISAM索引与InnoDB索引的区别？ InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引 InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效 MyISAM索引的叶子结点存储的是行数据地址，需要再寻址一次才能得到数据 InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询是做到覆盖索引会非常高效 25. InnoDB引擎的四大特性有哪些？ 插入缓冲（insert buffer） 二次写（double write） 自适应哈希索引（ahi） 预读（read ahead） 26. 你会如何根据业务场景选择存储引擎？如果没有特别的需求，使用默认的InnoDB即可 MyISAM：以读写插入为主的应用程序，比如博客系统，新闻门户网站。 InnoDB：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键，比如OA自动化办公系统。 27. 索引有哪些优缺点呢？索引的优点 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 索引的缺点 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率； 空间方面：索引需要占物理空间。 28. 什么情况可能会使用索引呢？where 、 order by 和 join 29. 创建索引的时候需要注意什么呢？通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。 索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况: 基于一个范围的检索，一般查询返回结果集小于表中记录数的30% 基于非唯一性索引的检索 30. 你知道什么是前缀索引吗？常用于什么场景吗？语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。 前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。 31. 什么是最左前缀原则？什么是最左匹配原则？ 顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式 32. B树和B+树的区别 在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。 B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。 33. 你知道数据库为什么使用B+树而不是B树吗？ B树只适合随机检索，而B+树同时支持随机检索和顺序检索； B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素； B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。 B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。 34. 什么是聚簇索引？ 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因 35. 非聚簇索引一定会回表查询吗？不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。 举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。 36. 联合索引是什么？为什么需要注意联合索引中的顺序？MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。 具体原因为: MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。 当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。 37. 什么是脏读？幻读？不可重复读？ 脏读(Drity Read)：某个事务已更新一份数据，另一个事务 在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。 38. MySQL中InnoDB引擎的行锁是怎么实现的？答：InnoDB是基于索引来完成行锁 例: select * from tab_with_index where id = 1 for update; for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起 39. 什么是死锁？怎么解决？死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。 常见的解决死锁的方法 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率； 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率； 40. 数据库的乐观锁和悲观锁是什么？怎么实现的？数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。 两种锁的使用场景 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。 但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 41. 谈一谈SQL的生命周期？ 应用服务器与数据库服务器建立一个连接 数据库进程拿到请求sql 解析并生成执行计划，执行 读取数据到内存并进行逻辑处理 通过步骤1的连接，发送结果到客户端 关掉连接，释放资源 42. 大表数据查询，怎么优化 优化shema、sql语句+索引； 第二加缓存，memcached, redis； 主从复制，读写分离； 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统； 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表； 43. 超大分页怎么处理？超大的分页一般从两个方向上来解决. 数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据. 从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击. 解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可. 44. 主键使用自增ID还是UUID？推荐使用自增ID，不要使用UUID。 因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。 总之，在数据量大一些的情况下，用自增主键性能会好一些。 关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。 45. 如果要存储用户的密码散列，应该使用什么字段进行存储？密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。 46. MySQL的复制原理以及流程主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。 主从复制的作用 主数据库出现问题，可以切换到从数据库。 可以进行数据库层面的读写分离。 可以在从数据库上进行日常备份。 MySQL主从复制解决的问题 数据分布：随意开始或停止复制，并在不同地理位置分布数据备份 负载均衡：降低单个服务器的压力 高可用和故障切换：帮助应用程序避免单点失败 升级测试：可以用更高版本的MySQL作为从库 MySQL主从复制工作原理 在主库上把数据更高记录到二进制日志 从库将主库的日志复制到自己的中继日志 从库读取中继日志的事件，将其重放到从库数据中 47. 数据表损坏的修复方式有哪些？使用 myisamchk 来修复，具体步骤： 修复前将mysql服务停止。 打开命令行方式，然后进入到mysql的/bin目录。 执行myisamchk –recover 数据库所在路径/*.MYI 使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库） 48. 什么情况下，你需要去优化你的数据库？ 系统的吞吐量瓶颈往往出现在数据库的访问速度上 随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢 数据是存放在磁盘上的，读写速度无法和内存相比 优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。 49. 如何在设计数据库的时候就优化数据库？一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。 需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。 将字段很多的表分解成多个表 对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。 因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。 增加中间表 对于需要经常联合查询的表，可以建立中间表以提高查询效率。 通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。 增加冗余字段 设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。 表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。 注意：冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。","link":"/2021/06/28/about-mysql/"},{"title":"面试中的网络常见问题","text":"网络是后端程序员面试必不可少的一个技能，整理一些面试会经常被问到的问题，便于复习查阅。 1. Http和Https的区别Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同： 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443； 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源； 开销：Https通信需要证书，而证书一般需要向认证机构购买； Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。 2. 对称加密与非对称加密对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。 3. 三次握手与四次挥手 三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)： 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 四次挥手(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)： 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 4. 为什么TCP链接需要三次握手，两次不可以么，为什么？为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。 客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。 5. TCP协议如何来保证传输的可靠性TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。 对于可靠性，TCP通过以下方式进行保证： 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据； 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层； 丢弃重复数据：对于重复数据，能够丢弃重复数据； 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒； 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。 6. 客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认。 DDos 攻击 客户端向服务端发送请求链接数据包 服务端向客户端发送确认数据包 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认 DDos 预防 ( 没有彻底根治的办法，除非不使用TCP ) 限制同时打开SYN半链接的数目 缩短SYN半链接的Time out 时间 关闭不必要的服务 7. Get与POST的区别GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面： 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源； 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变； 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体中。 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。 8. TCP与UDP的区别TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括： TCP是面向连接的，UDP是无连接的； TCP是可靠的，UDP是不可靠的； TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式； TCP是面向字节流的，UDP是面向报文的； TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信； TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大； 9. TCP的拥塞处理计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种： 慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小; 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。 快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 10. 从输入网址到获得页面的过程 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询； 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手； TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求； 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器； 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源； 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。 11. Session、Cookie 与 ApplicationCookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。 Application（Java Web中的ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。 12. Session 与 Cookie 的对比 实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID； 大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关； 安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全； 服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。 13. SQL 注入是什么？SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 SQL注入攻击的总体思路： 寻找到SQL注入的位置 判断服务器类型和后台数据库类型 针对不通的服务器和数据库特点进行SQL注入攻击 14. OSI网络体系结构与TCP/IP协议模型 物理层 参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。 数据链路层（data link layer） 接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。 网络层 将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。 传输层（transport layer） 在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信。 实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。 会话层（Session Layer） 会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密 表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。 应用层（Application layer）：为用户的应用进程提供网络通信服务 15. TCP和UDP分别对应的常见应用层协议有哪些？ TCP对应的应用层协议 FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。 Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。 SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。 HTTP：从Web服务器传输超文本到本地浏览器的传送协议。 UDP对应的应用层协议 DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。 16. 网络层的ARP协议工作原理网络层的ARP协议完成了IP地址与物理地址的映射。 17. IP地址的分类IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。 每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下： A类地址：以0开头，第一个字节范围：0~127； B类地址：以10开头，第一个字节范围：128~191； C类地址：以110开头，第一个字节范围：192~223； D类地址：以1110开头，第一个字节范围为224~239； E类地址：以1111开头，保留地址 18. IP地址与物理地址的关系物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。 19. 常见状态码及原因短语 HTTP请求结构： 请求方式 + 请求UR + 协议及其版本 HTTP响应结构： 状态码 + 原因短语 + 协议及其版本 1×× : 请求处理中，请求已被接受，正在处理 2×× : 请求成功，请求被成功处理200 OK 3×× : 重定向，要完成请求必须进行进一步处理301 : 永久性转移302 ：暂时性转移304 ： 已缓存 4×× : 客户端错误，请求不合法400：Bad Request,请求有语法问题403：拒绝请求404：客户端所访问的页面不存在 5×× : 服务器端错误，服务器不能处理合法请求500 ：服务器内部错误503 ： 服务不可用，稍等","link":"/2021/06/28/about-network/"},{"title":"110道python面试题","text":"一行代码实现1–100之和 利用sum()函数求和 如何在一个函数内部修改全局变量 函数内部global声明 修改全局变量 列出5个python标准库 os：提供了不少与操作系统相关联的函数 sys: 通常用于命令行参数 re: 正则匹配 math: 数学运算 datetime:处理日期时间 字典如何删除键和合并两个字典 del和update方法 谈下python的GIL GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。 多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大 python实现列表去重的方法 先通过集合去重，在转列表 fun(*args,*kwargs)中的args,**kwargs什么意思？ python2和python3的range（100）的区别 python2返回列表，python3返回迭代器，节约内存 一句话解释什么样的语言能够用装饰器? 函数可以作为参数传递的语言，可以使用装饰器 python内建数据类型有哪些 整型–int 布尔型–bool 字符串–str 列表–list 元组–tuple 字典–dict 简述面向对象中__new__和__init__区别 __init__是初始化方法，创建对象后，就立刻被默认调用了，可接收参数，如图 __new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别 __new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例 __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值 如果__new__创建的是当前类的实例，会自动调用__init__函数，通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。 简述with方法打开处理文件帮我我们做了什么？ 打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open 写法，我们需要try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行finally f.close()关闭文件，with方法帮我们实现了finally中f.close （当然还有其他自定义功能，有兴趣可以研究with方法源码） 列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25] map（）函数第一个参数是fun，第二个参数是一般是list，第三个参数可以写list，也可以不写，根据需求 python中生成随机整数. 随机小数. 0–1之间小数方法 随机整数：random.randint(a,b),生成区间内的整数 随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数 0-1随机小数：random.random(),括号中不传参 避免转义给字符串加哪个字母表示原始字符串？ r , 表示需要原始字符串，不转义特殊字符 中国，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的 python中断言方法举例 assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错 数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句 select distinct name from student 10个Linux常用命令 ls pwd cd touch rm mkdir tree cp mv cat more grep echo python2和python3区别？列举5个 Python3 使用 print 必须要以小括号包裹打印内容，比如 print(‘hi’) Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print ‘hi’ python2 range(1,10)返回列表，python3中返回迭代器，节约内存 python2中使用ascii编码，python中使用utf-8编码 python2中unicode表示字符串序列，str表示字节序列 python3中str表示字符串序列，byte表示字节序列 python2中为正常显示中文，引入coding声明，python3中不需要 python2中是raw_input()函数，python3中是input()函数 列出python中可变数据类型和不可变数据类型，并简述原理 不可变数据类型：数值型. 字符串型string和元组tuple 不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址），如下图用id()方法可以打印对象的id 可变数据类型：列表list和字典dict； 允许变量的值发生变化，即如果对变量进行append. +=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。 s = “ajldjlajfdljfddd”，去重并从小到大排序输出”adfjl” set去重，去重转成list,利用sort方法排序，reeverse=False是从小到大排 list是不 变数据类型，s.sort时候没有返回值，所以注释的代码写法不正确 用lambda函数实现两个数相乘 字典根据键从小到大排序 dic={“name”:”zs”,”age”:18,”city”:”深圳”,”tel”:”1362626627”} 利用collections库的Counter方法统计字符串每个单词出现的次数”kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h” 字符串a = “not 404 found 张三 99 深圳”，每个词中间是空格，用正则过滤掉英文和数字，最终输出”张三 深圳” 顺便贴上匹配小数的代码，虽然能匹配，但是健壮性有待进一步确认 filter方法求出列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表 列表推导式求列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 正则re.complie作用 re.compile是将正则表达式编译成一个对象，加快速度，并重复使用 a=（1，）b=(1)，c=(“1”) 分别是什么类型的数据？ 两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,3,6,7,8,9] extend可以将另一个集合中的元素逐一添加到列表中，区别于append整体添加 用python删除文件和用linux命令删除文件方法 python：os.remove(文件名) linux: rm 文件名 log日志中，我们需要用时间戳记录error,warning等的发生时间，请用datetime模块打印当前时间戳 “2018-04-01 11:38:54” 顺便把星期的代码也贴上了 数据库优化查询方法 外键. 索引. 联合查询. 选择特定字段等等 请列出你会的任意一种统计图（条形图. 折线图等）绘制的开源库，第三方也行 pychart. matplotlib 写一段自定义异常代码 自定义异常用raise抛出异常 正则表达式匹配中，（.）和（.?）匹配区别？ （.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配 （.*?）是非贪婪匹配，会把满足正则的尽可能少匹配 简述Django的orm ORM，全拼Object-Relation Mapping，意为对象-关系映射 实现了数据模型与数据库的解耦，通过简单的配置就可以轻松更换数据库，而不需要修改代码只需要面向对象编程,orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句,所有使用Django开发的项目无需关心程序底层使用的是MySQL. Oracle. sqlite….，如果数据库迁移，只需要更换Django的数据库引擎即可 [[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6] 列表推导式的骚操作 运行过程：for i in a ,每个i是【1,2】，【3,4】，【5,6】，for j in i，每个j就是1,2,3,4,5,6,合并后就是结果 还有更骚的方法，将列表转成numpy矩阵，通过numpy的flatten（）方法，代码永远是只有更骚，没有最骚 x=”abc”,y=”def”,z=[“d”,”e”,”f”],分别求出x.join(y)和x.join(z)返回的结果 join()括号里面的是可迭代对象，x插入可迭代对象中间，形成字符串，结果一致，有没有突然感觉字符串的常见操作都不会玩了 顺便建议大家学下os.path.join()方法，拼接路径经常用到，也用到了join,和字符串操作中的join有什么区别，该问题大家可以查阅相关文档，后期会有答案 举例说明异常模块中try except else finally的相关意义 try..except..else没有捕获到异常，执行else语句 try..except..finally不管是否捕获到异常，都执行finally语句 python中交换两个数值 举例说明zip（）函数用法 zip()函数在运算时，会以一个或多个序列（可迭代对象）做为参数，返回一个元组的列表。同时将这些序列中并排的元素配对。 zip()参数可以接受任何类型的序列，同时也可以有两个以上的参数;当传入参数的长度不同时，zip能自动以最短序列长度为准进行截取，获得元组。 a=”张明 98分”，用re.sub，将98替换为100 写5条常用sql语句 show databases; show tables; desc 表名; select * from 表名; delete from 表名 where id=5; update students set gender=0,hometown=”北京” where id=5 a=”hello”和b=”你好”编码成bytes类型 [1,2,3]+[4,5,6]的结果是多少？ 两个列表相加，等价于extend 提高python运行效率的方法 使用生成器，因为可以节约大量内存 循环代码优化，避免过多重复代码的执行 核心模块用Cython PyPy等，提高效率 多进程. 多线程. 协程 多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率 简述mysql和redis区别 redis： 内存型非关系数据库，数据保存在内存中，速度快 mysql：关系型数据库，数据保存在磁盘中，检索的话，会有一定的Io操作，访问速度相对慢 遇到bug如何处理 细节上的错误，通过print（）打印，能执行到print（）说明一般上面的代码没有问题，分段检测程序是否有问题，如果是js的话可以alert或console.log 如果涉及一些第三方框架，会去查官方文档或者一些技术博客。 对于bug的管理与归类总结，一般测试将测试出的bug用teambin等bug管理工具进行记录，然后我们会一条一条进行修改，修改的过程也是理解业务逻辑和提高自己编程逻辑缜密性的方法，我也都会收藏做一些笔记记录。 导包问题. 城市定位多音字造成的显示错误问题 正则匹配，匹配日期2018-03-20 url=’https://sycm.taobao.com/bda/tradinganaly/overview/get_summary.json?dateRange=2018-03-20%7C2018-03-20&amp;dateType=recent1&amp;device=1&amp;token=ff25b109b&amp;_=1521595613462' 仍有同学问正则，其实匹配并不难，提取一段特征语句，用（.*?）匹配即可 list=[2,3,5,4,9,6]，从小到大排序，不许用sort，输出[2,3,4,5,6,9] 利用min()方法求出最小值，原列表删除最小值，新列表加入最小值，递归调用获取最小值的函数，反复操作 写一个单列模式 因为创建对象时__new__方法执行，并且必须return 返回实例化出来的对象所cls.__instance是否存在，不存在的话就创建对象，存在的话就返回该对象，来保证只有一个实例对象存在（单列），打印ID，值一样，说明对象同一个 保留两位小数 题目本身只有a=”%.03f”%1.3335,让计算a的结果，为了扩充保留小数的思路，提供round方法（数值，保留位数） 求三个方法打印结果 fn(“one”,1）直接将键值对传给字典； fn(“two”,2)因为字典在内存中是可变数据类型，所以指向同一个地址，传了新的额参数后，会相当于给字典增加键值对 fn(“three”,3,{})因为传了一个新字典，所以不再是原先默认参数的字典 列出常见的状态码和意义 200 OK 请求正常处理完毕 204 No Content 请求成功处理，没有实体的主体返回 206 Partial Content GET范围请求已成功处理 301 Moved Permanently 永久重定向，资源已永久分配新URI 302 Found 临时重定向，资源已临时分配新URI 303 See Other 临时重定向，期望使用GET定向获取 304 Not Modified 发送的附带条件请求未满足 307 Temporary Redirect 临时重定向，POST不会变成GET 400 Bad Request 请求报文语法错误或参数错误 401 Unauthorized 需要通过HTTP认证，或认证失败 403 Forbidden 请求资源被拒绝 404 Not Found 无法找到请求资源（服务器无理由拒绝） 500 Internal Server Error 服务器故障或Web应用故障 503 Service Unavailable 服务器超负载或停机维护 分别从前端. 后端. 数据库阐述web项目的性能优化 该题目网上有很多方法，我不想截图网上的长串文字，看的头疼，按我自己的理解说几点 前端优化： 减少http请求. 例如制作精灵图 html和CSS放在页面上部，javascript放在页面下面，因为js加载比HTML和Css加载慢，所以要优先加载html和css,以防页面显示不全，性能差，也影响用户体验差 后端优化： 缓存存储读写次数高，变化少的数据，比如网站首页的信息. 商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。 异步方式，如果有耗时操作，可以采用异步，比如celery 代码优化，避免循环和判断次数太多，如果多个if else判断，优先判断最有可能先发生的情况 数据库优化： 如有条件，数据可以存放于redis，读取速度快 建立索引. 外键等 使用pop和del删除字典中的”name”字段，dic={“name”:”zs”,”age”:18} 列出常见MYSQL数据存储引擎 InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新. 删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性. 并发性要求比 较低，也可以使用。 MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。 计算代码运行结果，zip函数历史文章已经说了，得出[(“a”,1),(“b”,2)，(“c”,3),(“d”,4),(“e”,5)] dict()创建字典新方法 简述同源策略 同源策略需要同时满足以下三点要求： 1）协议相同 2）域名相同 3）端口相同 http:www.test.com与https:www.test.com 不同源——协议不同 http:www.test.com与http:www.admin.com 不同源——域名不同 http:www.test.com与http:www.test.com:8081 不同源——端口不同 只要不满足其中任意一个要求，就不符合同源策略，就会出现“跨域” 简述cookie和session的区别 1，session 在服务器端，cookie 在客户端（浏览器） session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效，存储Session时，键与Cookie中的sessionid相同，值是开发人员设置的键值对信息，进行了base64编码，过期时间由开发人员设置 cookie安全性比session差 简述多线程. 多进程 进程： 操作系统进行资源分配和调度的基本单位，多个进程之间相互独立 稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制 线程： CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源 如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃 应用： IO密集的用多线程，在用户输入，sleep 时候，可以切换到其他线程执行，减少等待的时间 CPU密集的用多进程，因为假如IO操作少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的线程会霸占GIL，其他线程没有GIL，就不能充分利用多核CPU的优势 简述any()和all()方法 any():只要迭代器中有一个元素为真就为真 all():迭代器中所有的判断项返回都是真，结果才为真 python中什么元素为假？ 答案：（0，空字符串，空列表. 空字典. 空元组. None, False） 测试all()和any()方法 IOError. AttributeError. ImportError. IndentationError. IndexError. KeyError. SyntaxError. NameError分别代表什么异常 IOError：输入输出异常 AttributeError：试图访问一个对象没有的属性 ImportError：无法引入模块或包，基本是路径问题 IndentationError：语法错误，代码没有正确的对齐 IndexError：下标索引超出序列边界 KeyError:试图访问你字典里不存在的键 SyntaxError:Python代码逻辑语法出错，不能执行 NameError:使用一个还未赋予对象的变量 python中copy和deepcopy区别 复制不可变数据类型，不管copy还是deepcopy,都是同一个地址当浅复制的值是不可变对象（数值，字符串，元组）时和=“赋值”的情况一样，对象的id值与浅复制原来的值相同。 复制的值是可变对象（列表和字典） 浅拷贝copy有两种情况： 第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。 第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值 ，会影响浅复制的值。 深拷贝deepcopy：完全复制独立，包括内层列表和字典 列出几种魔法方法并简要介绍用途 init:对象初始化方法 new:创建对象时候执行的方法，单列模式会用到 str:当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据 del:删除对象执行的方法 C:\\Users\\ry-wu.junya\\Desktop&gt;python 1.py 22 33命令行启动程序并传参，print(sys.argv)会输出什么数据？ 文件名和参数构成的列表 请将[i for i in range(3)]改成生成器 生成器是特殊的迭代器， 列表表达式的【】改为（）即可变成生成器 函数在返回值得时候出现yield就变成生成器，而不是函数了； 中括号换成小括号即可，有没有惊呆了 a = “ hehheh “,去除收尾空格 举例sort和sorted对列表排序，list=[0,-1,3,-10,5,9] 对list排序foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4],使用lambda函数从小到大排序 使用lambda函数对list排序foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4]，输出结果为 [0,2,4,8,8,9,-2,-4,-4,-5,-20]，正数从小到大，负数从大到小 （传两个条件，x&lt;0和abs(x)） 列表嵌套字典的排序，分别根据年龄和姓名排序 foo = [{“name”:”zs”,”age”:19},{“name”:”ll”,”age”:54}, {&quot;name&quot;:&quot;wa&quot;,&quot;age&quot;:17},{&quot;name&quot;:&quot;df&quot;,&quot;age&quot;:23}] 列表嵌套元组，分别按字母和数字排序 列表嵌套列表排序，年龄数字相同怎么办？ 根据键对字典排序（方法一，zip函数） 根据键对字典排序（方法二,不用zip) 有没有发现dic.items和zip(dic.keys(),dic.values())都是为了构造列表嵌套字典的结构，方便后面用sorted()构造排序规则 列表推导式. 字典推导式. 生成器 最后出一道检验题目，根据字符串长度排序，看排序是否灵活运用 举例说明SQL注入和解决办法 当以字符串格式化书写方式的时候，如果用户输入的有;+SQL语句，后面的SQL语句会执行，比如例子中的SQL注入会删除数据库demo 解决方式：通过传参数方式解决SQL注入 s=”info:xiaoZhang 33 shandong”,用正则切分字符串输出[‘info’, ‘xiaoZhang’, ‘33’, ‘shandong’] |表示或，根据冒号或者空格切分 正则匹配以163.com结尾的邮箱 递归求和 python字典和json字符串相互转化方法 json.dumps()字典转json字符串，json.loads()json转字典 MyISAM 与 InnoDB 区别： InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高 级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM 就不可以了； MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到 安全性较高的应用； InnoDB 支持外键，MyISAM 不支持； 对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中可以和其他字段一起建立联合索引； 清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重 建表； 统计字符串中某字符出现次数 字符串转化大小写 用两种方法去空格 正则匹配不是以4和7结尾的手机号 简述python引用计数机制 python垃圾回收主要以引用计数为主，标记-清除和分代清除为辅的机制，其中标记-清除和分代回收主要是为了处理循环引用的难题。 引用计数算法当有1个变量保存了对象的引用时，此对象的引用计数就会加1 当使用del删除变量指向的对象时，如果对象的引用计数不为1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除 int(“1.4”),int(1.4)输出结果？ int(“1.4”)报错，int(1.4)输出1 列举3条以上PEP8编码规范 顶级定义之间空两行，比如函数或者类定义。 方法定义. 类定义与第一个方法之间，都应该空一行 三引号进行注释 使用Pycharm. Eclipse一般使用4个空格来缩进代码 正则表达式匹配第一个URL findall结果无需加group(),search需要加group()提取 正则匹配中文 简述乐观锁和悲观锁 悲观锁, 就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量 r. r+. rb. rb+文件打开模式区别 模式较多，比较下背背记记即可 Linux命令重定向 &gt; 和 &gt;&gt; Linux 允许将命令执行结果 重定向到一个 文件 将本应显示在终端上的内容 输出／追加 到指定文件中 表示输出，会覆盖文件原有的内容 表示追加，会将内容追加到已有文件的末尾 用法示例： 将 echo 输出的信息保存到 1.txt 里echo Hello Python &gt; 1.txt将 tree 输出的信息追加到 1.txt 文件的末尾tree &gt;&gt; 1.txt99. 正则表达式匹配出www.itcast.cn 前面的&lt;&gt;和后面的&lt;&gt;是对应的，可以用此方法 python传参数是传值还是传址？ Python中函数参数是引用传递（注意不是值传递）。对于不可变类型（数值型. 字符串. 元组），因变量不能修改，所以运算不会影响到变量自身；而对于可变类型（列表字典）来说，函数体运算可能会更改传入的参数变量。 求两个列表的交集. 差集. 并集 生成0-100的随机数 random.random()生成0-1之间的随机小数，所以乘以100 lambda匿名函数好处 精简代码，lambda省去了定义函数，map省去了写for循环过程 常见的网络传输协议 UDP. TCP. FTP. HTTP. SMTP等等 单引号. 双引号. 三引号用法 单引号和双引号没有什么区别，不过单引号不用按shift，打字稍微快一点。表示字符串的时候，单引号里面可以用双引号，而不用转义字符,反之亦然。 ‘She said:”Yes.” ‘ or “She said: ‘Yes.’ “ 但是如果直接用单引号扩住单引号，则需要转义，像这样： ‘ She said:'Yes.' ‘ 三引号可以直接书写多行，通常用于大段，大篇幅的字符串 “”” hello world “”” python垃圾回收机制 python垃圾回收主要以引用计数为主，标记-清除和分代清除为辅的机制，其中标记-清除和分代回收主要是为了处理循环引用的难题。 引用计数算法当有1个变量保存了对象的引用时，此对象的引用计数就会加1 当使用del删除变量指向的对象时，如果对象的引用计数不为1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除 HTTP请求中get和post区别 GET请求是通过URL直接请求数据，数据信息可以在URL中直接看到，比如浏览器访问；而POST请求是放在请求头中的，我们是无法直接看到的； GET提交有数据大小的限制，一般是不超过1024个字节，而这种说法也不完全准确，HTTP协议并没有设定URL字节长度的上限，而是浏览器做了些处理，所以长度依据浏览器的不同有所不同；POST请求在HTTP协议中也没有做说明，一般来说是没有设置限制的，但是实际上浏览器也有默认值。总体来说，少量的数据使用GET，大量的数据使用POST。 GET请求因为数据参数是暴露在URL中的，所以安全性比较低，比如密码是不能暴露的，就不能使用GET请求；POST请求中，请求参数信息是放在请求头的，所以安全性较高，可以使用。在实际中，涉及到登录操作的时候，尽量使用HTTPS请求，安全性更好。 python中读取Excel文件的方法 应用数据分析库pandas 简述多线程. 多进程 进程： 操作系统进行资源分配和调度的基本单位，多个进程之间相互独立 稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制 线程： CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源 如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃 应用： IO密集的用多线程，在用户输入，sleep 时候，可以切换到其他线程执行，减少等待的时间 CPU密集的用多进程，因为假如IO操作少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的线程会霸占GIL，其他线程没有GIL，就不能充分利用多核CPU的优势 python正则中search和match","link":"/2021/06/28/python-interview/"},{"title":"软件测试面经总结","text":"软件测试面经总结： 优炫软件 没过 一、优炫软件 时间：07月07日 14:00 时长：笔试题约1h 面试约40min 总结： 需要提前准备影响深刻的项目和模块；（PS响应式：首页展示。发现页面修改数据没有改变，导致自动化脚本执行失败，后来发现是客户端缓存的问题 ） ui自动化的架构没有说清楚；（PS：基础类、PO类、测试类、Log模块、email模块、全局配置模块、文件读取模块） 项目的模块描述不够清楚。（PS：权限模块） 1. 自我介绍吧啦吧啦的讲了一小会，算是磕磕绊绊的讲完的吧，有一丢丢紧张 2. 介绍在上一家映像深刻的项目啊，我说了ums会议系统：是以会议为核心的，可以实现会议、会议室预定、会议签到、会议签出、会议过程中会议记录、会议室设备管理、人员管理、权限管理的前后端分离的系统，可以实现多端的联动，包括手机端、中台、门牌以及大屏。前面是做手工测试，然后加入了自动化测试 3. 自动化测试有哪些呢？web自动化和接口自动化，我主要搭建自动化测试框架，写了部分测试用例，部分模块的用例是交给同事写的 4. 你映像深刻的模块是哪个部分，可以说一下怎么设计测试用例的吗？额，大型尴尬场面，我说了没有，呜呜呜，随便扯了一个，权限模块，巴拉巴拉扯了一堆没有用的东西，死掉了，设计测试用例，说了新增，没说删、查、改，面试小姐姐补充了，社死现场，估计以为我是培训出来的。呜呜呜（小哥哥说，这种要准备一下，让话语权在自己手上，我我我，就这样无了） 5. jmeter实现接口测试还是实现压测？啊，我答了什么，啊，记不大清楚了 6. jmeter如何测出压测的峰值先看需求，需求会决定（哼哼，我们需求里没有），啊，没有呀，就根据以往的经验来，阶段性，增加并发数量，压测5min，查看服务器的cpu和系统吞吐量，当达到峰值后，继续压测，系统吞吐量会有一个下降趋势，就可以确定压测的峰值范围。 7. 有一个接口，jmeter实现接口关联？先通过登录接口测试，从登录中拿到token，将token设置为全局变量，然后再接口的请求中传入token全局变量。 正则表达式提取器，获取token，将token作为入参传入 8. 介绍一下自动化框架没怎么理解，回答的是了python+selenium，进一步询问了，自动化框架的目录结构：基础类：封装基础的参数和操作，进一步封装的po类，页面对象类，测试类，log日志模块类、email邮件类，读取文件的类还有一些配置文件这些。 9. 你有什么想问的？技术栈（Python）、人员配置(大概300人，测试有20人左右，配置比例看项目大小，自己的会多一点)、是否用到cicd（用到了cd，jenkins)","link":"/2021/07/07/interview-review/"},{"title":"linux Q&amp;A","text":"一、基础项 查看文件行数：wc -l a.txt 查看前10行：head -n 10 a.txt 查看后10行：tail -n 10 a.txt。 查看运行中的程序：ps -aux | grep mysql 查看性能：top 查看端口：netstat -nltp 查看文件内容和保存：vim a.txt 或者 vi a.txt，vim是vi的升级版，兼容vi并比vi更强大。保存使用:wq 二、系统项 如何查看系统内核的版本：uname -a或者cat /proc/version 如何查看系统当前的 IP 地址：ifconfig -a或者ip addr show 如何查看磁盘还有多少剩余空间：df -ah 如何在系统中管理服务： 查看服务状态：service/ [servicename] status 或者 systemctl status [servicename] 启动/停止/重启服务：service [servicename] [start|stop|restart] 或者 systemctl [start|stop|restart] [servicename] 重新加载服务配置文件（不重启服务）：service [servicename] [reload] 或者 systemctl [reload] [servicename] 如何查看一个目录的大小：du -sh [目录] 如何查看你系统中开放的端口号：netsat -tulpn 或者 ss 如何查看某个进程对 CPU 的使用情况： 可以使用 top 命令。top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 使用 ps 命令。ps aux可以显示所有使用者的进程，最常用的方法是ps aux，然后再利用一个管道符号导向到grep去查找特定的进程。比如查看nginx 进程可以用ps aux | grep nginx Linux里如何来做挂载：mount 如何查看一些你不太熟悉的命令：man 或者 网络查资料 三、填空项 在Linux 系统 中，以文件方式访问设备 。 Linux 内核引导时，从文件/etc/fstab中读取要加载的文件系统 。 Linux 文件系统中每个文件用indoe-i``节点来标识。 全部磁盘块由四个部分组成，分别为引导块 、专用块 、 i 节点表块 和 数据存储块 。 链接分为：硬链接 和 符号链接 。 超级块包含了i节点表 和 空闲块表 等重要的文件系统信息。 某文件的权限为：d-rw-_r–_r–，用数值形式表示该权限，则该八进制数为：644 ，该文件属性是目录 。 前台启动的进程使用Ctrl+c 终止。 静态 路由 设定后，若 网络 拓扑结构发生变化，需由系统 管理 员 修改路由的 设置 。 网络管理的重要任务是：控制 和 监控 。 安装Linux 系统对硬盘分区时，必须有两种分区类型：文件系统分区 和 交换分区 。 编写的 Shell 程序运行前必须赋予该脚本文件执行 权限。 系统管理的任务之一是能够在分布式 环境中实现对程序和数据的安全保护、备份、恢复和更新。 系统交换分区是作为系统虚拟存储器 的一块区域 。 内核分为进程管理系统 、 内存管理系统 、 I/O 管理系统 和文件管理系统 等四个子系统。 内核配置是系统管理员在改变系统配置硬件 时要进行的重要操作。 在安装Linux 系统中，使用netconfig 程序对网络进行配置，该安装程序会一步步提示用户 输入主机名、域名、域名服务器 、IP地址、网关地址 和子网掩码 等必要信息。 唯一标识每一个用户的是用户ID 和用户名 。 RIP 协议 是最为普遍的一种内部协议，一般称为动态路由信息协议 。 在Linux 系统中所有内容都被表示为文件，组织文件的各种方法称为文件系统 。 DHCP 可以实现动态 IP 地址分配。 系统网络管理员的管理对象是服务器 、用户 和服务器的进程 以及系统的各种资源。 网络管理通常由监测、传输和管理 三部分组成，其中管理部分是整个网络管理的中心。 当想删除本系统用不上的设备驱动程序 时必须编译内核，当内核不支持系统上的设备驱动程序 时，必须对内核升级 。 Ping 命令可以测试网络中本机系统是否能到达一台远程主机 ，所以常常用于测试网络的连通性 。 vi 编辑器具有两种工作模式： 命令 模式 和 输入模式 。 可以用ls –al 命令来观察文件的权限，每个文件的权限都用10 位表示，并分为四段，其中第一段占 1 位，表示 文件类型 ，第二段占3 位，表示文件所有者对该文件的权限。 进程与程序的区别在于其动态性，动态的产生和终止，从产生到终止进程可以具有的基本状态为：运行态 、 就绪态 和 等待态（阻塞态） 。 DNS 实际上是分布在internet 上的主机信息的数据库 ，其作用是实现IP地址和主机名之间的转换。 Apache 是实现WWW服务器功能 的 应用 程序，即通常所说的浏览web 服务器，在服务器端为用户提供浏览 web 服务的就是apache 应用程序。 在Linux 系统上做备份可以有两种类型：系统备份 和用户备份 。其中前者是指对操作系统的备份，后者是指对应用程序和用户文件的备份 。 在使用ls 命令时，用八进制形式显示非打印字符应使用参数-b 。 Linux 使用支持 Windows 9.x/2000 长文件名的文件系统的类型是 vfat 。 设定限制用户使用磁盘空间的命令是quota。 在Linux 系统中，用来存放系统所需要的配置文件和子目录的目录是/etc 。 硬连接只能建立对文件 链接。符号链接可以跨不同文件系统创建。 套接字文件的属性位是s 。 结束后台进程的命令是kill 。 进程的运行有两种方式，即独立运行和使用父进程运行 。 Links 分为硬链接和符号链接 。 在超级用户下显示Linux 系统中正在运行的全部进程，应使用的命令及参数是ps-aux 。 管道文件的属性位是p 。 将前一个命令的标准输出作为后一个命令的标准输入，称之为管道 。 为脚本程序指定执行权的命令及参数是chmod a+x filename 。 进行远程登录的命令是telnet 。 欲发送10个分组报文测试与主机abc.tuu.edu.cn 的连通性，应使用的命令和参数是：ping abc.tuu.edu.cn –c 10 。 DNS 服务器的进程命名为named，当其启动时，自动装载 /etc 目录下的named.conf 文件中定义的DNS 分区数据库文件。 Apache 服务器进程配置文件是httpd.conf 。 在 Linux 系统中，压缩文件后生成后缀为.gz文件的命令是gzip 。 在用vi 编辑文件时，将文件内容存入test.txt 文件中，应在命令模式下键入 ：wtest.txt 。 可以在标准输出上显示整年日历的命令及参数是cal -y 。 在shell 编程时，使用方括号表示测试条件的规则是：方括号两边必须有空格 。 检查已安装的文件系统/dev/sda5 是否正常，若检查有错，则自动修复，其命令及参数是fsck –a /dev/sda5 。 在Windows9.x 环境下共享Unix/Linux 中的用户目录的一个工具是Samba 服务器 。 系统管理员的职责是进行系统资源管理、系统性能管理、设备管理、安全管理和系统性能监测 。 在Linux 系统中，测试DNS 服务器是否能够正确解析 域名的的客户端命令，使用命令nslookup 。 在Linux 系统下，第二个IDE 通道的硬盘（从盘）被标识为sdb 。 当系统管理员需升级内核版本和改变系统硬件配置时，应重新编译内核 。 如果只是要修改系统的IP 地址，应修改/etc/rc.d/rc.inet1 配置文件。 当LAN 内没有条件建立DNS 服务器，但又想让局域网内的用户可以使用计算机名互相访问时，应配置/etc/hosts 文件。 在vi 编辑环境下，使用Esc 键 进行模式转换。 Slackware Linux 9.0 通常使用ext3 文件系统，系统的全部磁盘块由四 部分组成。 将/home/stud1/wang 目录做归档压缩，压缩后生成wang.tar.gz 文件，并将此文件保存到/home 目录下，实现此任务的tar 命令格式tar zcvf /home/wang.tar.gz/home/stud1/wang 。 管道就是将前一个命令的 标准输出 作为后一个命令的标准输入 。 在使用手工的方法配置网络时，可通过修改/etc/HOSTNAME 文件来改变主机名，若要配置该计算机的域名解析客户端，需配置/etc/resolv.conf 文件。 启动进程有手动启动和调度启动两种方法，其中调度启动常用的命令为 at 、 batch和 crontab 。 test.bns.com.cn 的域名是bns.com.cn ，如果要配置一域名服务器，应在named.conf 文件中定义DNS 数据库的工作目录。 Sendmail 邮件系统使用的两个主要协议是：SMTP 和 POP ，前者用来发送邮件,后者用来接收邮件。 DHCP 是动态主机配置协议的简称，其作用是：为网络中的主机分配IP 地址 。 目前代理服务器使用的软件包有很多种，教材中使用的是squid 。 rm 命令可删除文件或目录，其主要差别就是是否使用递归开关-r。 mv 命令可以移动文件和目录，还可以为文件和目录重新命名。 路由选择 协议（RIP）的跳数表示到达目的地之前必须通过的网关 数，RIP 接受的最长距离是15 跳 。 ping 命令用于测试网络的连通性，ping 命令通过ICMP 协议（internet 控制信息协议）来实现。 nfs 协议 用于实现 Unix （/linux）主机之间的文件系统共享。 shell 不仅是用户命令的解释器 ，它同时也是一种功能强大的编程语言。 bash 是Linux 的缺省shell。 用&gt;&gt; 符号将输出重定向内容附加在原文的后面。 增加一个用户的命令是：adduser 或useradd 。 进行字符串查找，使用grep 命令。 使用* 每次匹配若干个字符。 /sbin 目录用来存放系统管理员使用的管理程序。","link":"/2021/07/08/linux-q-a/"}],"tags":[{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"pointer","slug":"pointer","link":"/tags/pointer/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"rpc","slug":"rpc","link":"/tags/rpc/"},{"name":"软件测试","slug":"软件测试","link":"/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"kernel","slug":"kernel","link":"/tags/kernel/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"interview python","slug":"interview-python","link":"/tags/interview-python/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"linux 面试","slug":"linux-面试","link":"/tags/linux-%E9%9D%A2%E8%AF%95/"}],"categories":[{"name":"interview","slug":"interview","link":"/categories/interview/"}]}